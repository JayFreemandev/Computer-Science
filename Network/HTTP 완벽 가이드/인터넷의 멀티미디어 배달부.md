# 인터넷의 멀티미디어 배달부

# Topic

1. HTTP
2. 웹 클라이언트와 서버
3. URL과 URI
4. TCP
5. 웹 구성요소

## HTTP

HpyerText Transfer Protocol 브라우저 상에서 데이터를 전달할 때 사용되는 통신규약을 의미한다. 이를 책에서는 **인터넷의 멀티미디어 배달부** 라고 표현한다. 

신뢰성 있는 데이터 전송 프로토콜을 사용하기 때문에 전송 중 장애 방지를 보장하고 개발자가 HTTP통신중의 결함이나 약점에 대한 걱정 없이 기능을 구현하게 도와준다.

## 웹 클라이언트와 서버

웹 서버 → 데이터를 저장, 요청을 HTTP 응답으로 제공

웹 클라이언트(브라우저) → 서버에 HTTP 요청을 보냄

1. 클라이언트(사용자)는 서버에게 데이터를 요청한다. (/index.html 이라는 문서 보여줘)
2. 서버는 요청된 데이터를 찾아 HTTP 응답으로 돌려준다.(/index.html 여기! xx타입이고 2000자다)

예를들어 브라우저를 켜서 [http://google.com/index.html](http://google.com/index.html) 를 입력하면, 브라우저는 사용자가 입력한 HTTP 요청을 [http://google.com](http://google.com/) 서버로 보낸다. 구글 서버는 요청을 받은 /index.html 객체를 찾고, 성공하면 객체의 타입, 길이 등의 정보와 함께 HTTP 응답에 실어 브라우저에게 보낸다.

### 리소스

웹 서버는 리소스를 관리하고 제공하는데, 리소스란 텍스트파일, HTML, 워드 등 정적인 파일이나 실시간 라이브 영상같은 동적 콘텐츠를 의미한다. 

## URI

웹 서버 리소스는 각자 이름을 가지고 있는데 리소스 이름은 **통합 자원 식별자(uniform resource identifier) URI**로 불린다

`http://google.com/index.html`

구글에게 요청한 리소스 URI를 HTTP 프로토콜은 다음과 같이 해석한다.

1. http:// => HTTP 프로토콜을 사용하라
2. [www.google.com](http://www.google.com/) => [www.google.com으로](http://www.google.xn--com-ky7m580d/) 이동하라
3. /index.html => /index.html 이라 불리는 리소스를 가져와라

URI는 URL과 URN 두 종류로 나뉜다.

URN → **유니폼 리소스 이름(uniform resource name) URN**은 리소스의 **위치에 영향 받지 않는**유일한 이름 역할을 한다. 즉, 리소스의 위치가 변하더라도 문제없이 동작한다.

URL → **통합 자원 지시자(uniform resource locator) URL**은 리소스 식별자의 가장 흔한 형태다. URL은 특정 서버의 한 리소스에 대한 **구체적인 위치**를 서술한다.

대부분의 URL은 세 부분으로 이루어진 표준 포맷을 따른다.

- 첫 번째 부분은 스킴(scheme) 이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술한다.
- 두 번째 부분은 서버의 인터넷 주소를 제공한다
- 마지막은 웹 서버의 리소스를 가리킨다.

## 트랜잭션

HTTP 트랜잭션은 요청 명령, 응답 결과로 구성되어있다.

- GET : 서버에서 클라이언트로 지정한 리소스를 보내라
- PUT : 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라
- DELETE : 지정한 리소스를 서버에서 삭제하라
- POST : 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라
- HEAD : 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라

## TCP

HTTP → 애플리케이션 계층 프로토콜. 네트워크의 세부사항 신경안쓰고 인터넷 전송 프로토콜인 TCP에게 토스한다.

TCP는 다음과 같은 기능을 제공한다 

- 오류 없는 데이터 전송
- 순서대로 전달
- 조각나지 않는 데이터 스트림(언제든 어떤 크기로든)

이런 TCP/IP는 TCP와 IP가 층을 이루는 패킷 교환 프로토콜의 집합 → 하드에어와 네트워크의 특성을 숨기고 어떤 종류의 컴퓨터에서도 신뢰성있는 의사소통을 제공 

TCP 커넥션이 맺어지면 클라이언트와 서버간의 교환되는 메세지는 없어지거나 순서가 뒤바껴서 전달되는 일은 없다.
![Untitled](https://user-images.githubusercontent.com/72185011/195969085-416bbbf4-ba6d-4ee3-863b-3e630c22c0ca.png)
네트워크 개념상, HTTP 프로토콜은 TCP 위의 계층입니다. HTTP 는 자신의 메시지 데이터를 전송하기 위해 TCP 를 사용한다.

HTTP 클라이언트가 서버에게 메세지를 전송하려면 IP주소와 포트번호를 사용해서 클라이언트 ↔ 서버 사이에 TCP 커넥션을 맺어야한다. 도메인 URL을 입력하면 DNS를 통해 IP로 변환하고 URL에서 포트번호를 추출한다.

HTTP 프로토콜 버전별 진화

초기 0.9 

→ GET만 지원하고 HTML을 받아오기 위해 만들어짐 

1.0

→ 헤더, 멀티미디어 시각적으로 변화 WWW 인기 

1.0+

→ 오래 지속되는 keep alive 커넥션, 가상 호스팅, 프록시 

1.1

→ 설계의 구조적 단점 수정, 성능 최적화(커낵션 재사용, 청크응답, 파이프라이닝)

2.0

→ 1.1 성능 문제 계선하려고 구글 프로토콜 기반 설계, 이진 프로토콜, 다중화 프로토콜 (병렬 요청 가능), 오버헤드 제거, 서버푸쉬 => 응답성 증가

## 웹 구성요소

프록시

- 클라이언트 ↔ 서버 사이의 HTTP 중개자
- 클라이언트의 모든 요청을 서버에 대신 전달(보통 요청을 수정)
- 요청/응답 필터링 → 보안 증가

캐시

- 자주 방문한 페이지 사본을 클라이언트 가까이에 저장하는 HTTP 저장소
- 효율성 증가

게이트웨이

- 다른 어플리케이션과 연결된 특별한 웹 서버
- 다른 서버간의 중개자
- 클라이언트는 진짜 서버로 인식
- HTTP트래픽을 다른 프로토콜로 변환 EX) HTTP→FTP

터널

- HTTP 단순 전달만 하는 특별한 프록시
- 두 연결 사이에서 raw 데이터 열지 않고 그대로 전달
- 주로 비 HTTP 데이터를 HTTP 연결을 통해 전송할때 사용
- EX) HTTPS 정보 방화벽을 통과시키는 HTTP/SSL 터널

에이전트

- HTTP 요청 생성하는 웹 클라이언트
- - 사용자 웹 클라이언트 : 웹 브라우저
- EX 동화된 준지능적(semi-intelligent) 에이전트: 스파이더, 웹로봇 등
