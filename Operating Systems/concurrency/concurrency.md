# 락, 세마포어 그리고 데드락

프로세스를 위한 새로운 개념인 쓰레드를 소개한다.   
프로그램에서 한 순간에 하나의 명령어만을 실행하는 단일 PC의 고전적인 관점에서 벗어나   
멀티 쓰레드 프로그램은 하나 이상의 실행 포인트를 가지고 있다.   

멀티 쓰레드를 이해하는 다른 방법은 각 쓰레드가 프로세스와 매우 유사하지만,   
차이가 있다면 쓰레드들은 주소 공간을 공유하기 때문에 **동일한 값에 접근**   
하지만 하나의 쓰레드의 상태는 프로세스의 상태와 비슷하다.   
쓰레드는 어디서 명령어들을 불러 들일지 알려주는 PC와 연산을 위한 레지스터들을 가지고있다.   

만약 두 개의 쓰레드가 하나의 프로세서에서 실행 중이라면 실행하고자 하는    
쓰레드 T2는 반드시context switch를 통해 실행 중인 쓰레드 T1와 교체 되어야 한다.            
쓰레드 간의 문맥 교환은 T1이 사용하던 레지스터들을 저장하고 T2가사용하던        
레지스터의 내용으로 복원한다는 점에서 프로세스의 문맥 교환과 유사하다.           

프로세스가 문맥 교환을 할 때에 프로세스의 상태를 프로세스 제어 블럭(process control block, PCB)에 저장하듯이             
프로세스의 쓰레드들의 상태를 저장하기 위해서는           
하나 또는 그 이상의 **쓰레드 제어 블럭(thread control block, TCB)**이 필요하다.              

가장큰 차이 중 하나는 프로세스와 달리 쓰레드 간의 문맥 교환에서는 **주소 공간을 그대로 사용**한다는 것이다.   
쓰레드와 프로세스의 또 다른 차이는 **스택**에 있다.    
기본 프로세스 주소 공간과 같은 간단한 모델 (단일 쓰레드 프로세스)에서는 스택이 하나만 존재한다.  

반면에 멀티 쓰레드 프로세스의 경우에는 각 쓰레드가 독립적으로 실행되며      
쓰레드가 실행하기 위해 여러 루틴들을 호출할 수 있다.    
주소 공간에는 하나의 스택이 아니라 **쓰레드마다 스택이 할당**되어 있다.     
두 개의 쓰레드를 가지는 멀티 쓰레드 프로세스의 주소 공간은 단일 쓰레드 프로세스의 주소 공간과 다르다.    

![Untitled 1](https://user-images.githubusercontent.com/72185011/175782293-033224b2-741e-46db-b026-fedf4390be0d.png)


두 개의 스택이 프로세스 주소 공간에 존재하는 것을 볼 수 있다.     
스택에서 할당되는 변수들이나 매개변수, 리턴 값, 그리고 그 외에 스택에 넣는 것들은  
해당 **쓰레드의 스택인 쓰레드-로컬 저장소 (thread-local storage)라 불리는 곳에 저장**된다   

쓰레드-로컬 저장소로 인해서 정교한 주소 공간의 배치가 삐뚤어진다.   
전에는 스택과 힙이 독립적으로 확장되기 때문에 주소 공간에 더 이상 공간이 없는 경우에만 문제가 생겼다.   
이제는 상황이 예전처럼 깔끔하지 않다. 다행스러운것은 스택의 크기가 아주 크지 않아도 되기 때문에  
대부분의 경우에는 문제가 되지않는다 (재귀 호출 제외)   
<br>
## 데이터의 공유

쓰레드는 일을 복잡하게 만든다. 간단한 코드 예시 일지라도 어떤 쓰레드가 언제 실행되는지는 알기 힘들고.   
컴퓨터는 스레드때문에 더 복잡해지고 어려워졌다. 병행성이라는 주제가 아니여도 충분히 복잡한데 말이다.   

예를 들어 쓰레드 두개가 공유 변수 카운터에 천만번씩 더한다치자 당연히 우리가 원하는 출력값은20,000,000이다.  
안타깝게도 멀티프로세서가아닌 싱글 프로세서일지라도 2천만이 안나온다.  

![Untitled 2](https://user-images.githubusercontent.com/72185011/175782427-a6d0010b-3c6d-4aac-b325-bf1d57ecc6f4.png)

각 실행이 잘못되었을 뿐만 아니라 각 실행의 결과도 다르다.

컴파일러가 생성한 코드의 실행 순서를 이해해야 한다 명령어의 실행 순서에 따라 결과가 달라지는   
상황을 **경쟁 조건(racecondition)**이라고 부른다.  
문맥 교환이 때에 맞지 않게 실행되는 운이 없는 경우 잘못된결과를 얻게 된다.     

사실, 경쟁 조건에 처한 경우 실행할 때마다 다른 결과를 얻는다.   
퓨터의 작동에서 일반적으로 발생하는 결정적 결과와 달리 결과가 어떠할지 알지못하거나   
실행할 때마다 결과가 다른 경우를 **비결정적(indeterminate)인 결과**라고 부른다.   

멀티 쓰레드가 같은 코드를 실행할 때 경쟁 조건이 발생하기 때문에 공유 자원을 접근하고   
하나 이상의 쓰레드에서 동시에 실행되면 안 되는 코드를 **임계영역**이라 부른다.   

이러한 코드에서 필요한 것은 **상호 배제**(mutual exclusion)다.    
상호배제는 하나의 쓰레드가 임계 영역 내의 코드를 실행 중일 때는 다른 쓰레드가 실행할 수 없도록 보장해준다.  

임계 영역 문제에 대한 해결 방법 중 하나로 강력한 명령어 한 개로 의도한 동작을 수행하여,  
**인터럽트 발생 가능성을 원천적으로 차단하는 것**이다  

## 왜 운영체제에서 똥을 치워야 하는가?

운영체제의 역사를 보면 그래왔기 때문이다. 운영체제는 최초로    
병행 프로그램 사용을 목적으로 다양한 기법들이 개발되었다.    
나중에는 멀티 쓰레드 프로그램이 등장하면서 응용 프로그래머들도 이러한 문제를 고민하게 되었다  

시도 때도 없이 발생하는 **인터럽트가 앞서 언급한 모든 문제들의 원인**이다   

**원자적 연산 (atomic operation)을 사용하자**

원자적 연산들은 컴퓨터 시스템을 이루는 가장 강력한 기술 중에 하나로서  
우리가 지금 다루고 있는 병행 코드, 파일 시스템들과 데이터베이스 관리 시스템들 그리고 분산 시스템들의 근본 기술이다.  

연속된 동작들을 원자적으로 만든다는 개념은 간단하게 “맞으면 맞고 아니면 아니고”라고 표현할 수 있다.   
수행하려는 모든 동작이 모두 다 처리된 것처럼 보이거나 실행되다가만 중간 상태가   
없도록 아무 것도 실행되지 않은 것처럼 보여야 한다.   

때로는 여러동작을 묶어 하나의 원자적 동작이 되도록 만든 것을 트랜젝션이라고 부른다. 이 개념은   
데이터베이스와 트랜젝션 처리분야에서 깊이 있게 다루고 있다  

## 락

병행성에 대한 소개 이후 병행 프로그램의 근본적인 문제 몇 개를 살펴보았다.   
여러 개의 명령어들을 원자적으로 실행해보고 싶지만 단일 프로세서의 인터럽트로 인해서   
(또는 멀티 쓰레드를 여러 프로세서에 동시 접근 하려고 해서) 그렇게 할 수가없었다.  

락(lock)을 이용하여 이 문제를 직접적으로 다루고자 한다.    
프로그래머들은 소스 코드의 임계 영역을 락으로 둘러서    
그 임계 영역이 마치 하나의 원자 단위 명령어인것처럼 실행되도록 한다.   

## 락의 조건

락을 만들려면 하드웨어와 OS의 지원이 필요한데 다음 세가지의 조건이 필요하다.  
첫번째로는 락이 상호 배제를 제공해야한다. 왜냐하면 락이 상호 배제를 지원하기위해 등장한 개념이기 때문이다.   
두번째로는 공정성이다. 락은 여러 스레드가 접근할때 공평하게 접근 권한을 줄 수 있는지   
특정 스레드가 계속 락을 얻지 못한다면 굶어죽게되는 기아상태가 발생하기 때문이다.  

세번째로는 성능이다.   

### 인터럽트 제어

모든 문제의 원인인 인터럽트를 OFF 해버리면 해결되지않을까?   
간단해보이지만 인터럽트를 꺼버리면 나쁜 목적의 스레드가 락을 쥐고 안줘서  
프로세스를 독점하거나 OS의 제어권을 루프돌며 주지않을수도있다.    
락 줄때마다 인터럽트 껐다 켯다하는 명령어가 가벼운 명령어가 아니다.  
해당 방법은 아주 신뢰성이 높은 작업말고는 사용되지않는다.   

### 청기들어 백기들어

FLAG 0과 1로 0이면 락이 없는거고 1이면 누군가 락을 가지고있는 상태로 알고있는다.    
즉 반복문을 돌며 0을 리턴하면 락을 희득하는 방법이다. 이렇게 하면 내가 락을 얻을때   
다른 스레드는 빙빙 무한루프를 돌고있게된다. 성능에 좋지못한 방법이다.    

### 도와줘요 하드웨어

그냥 하드웨어의 도움을 받기로한다. test and set 명령어를 통해 이전에 포인터 값을 반환하고    
새로운 포인터값을 설정한다.새로운 값을 전환하면서 락을 얻을수있는 스레드인지 확인하게된다.      
해당 명령어는 원자적으로 이루어져있어서 아니면 아니고 맞으면 락주는거다.    
간단하지만 spin wait, 빙빙 도는 상태는 해결하지 못했다.   
  
### 아니 둘다 도와줘요 하드웨어, 운영체제

지금까지 알아본 여러 가지 방법들은 하드웨어 기반 lock이었으며 간단하게 코드 몇 줄로 작동됐다.    
하지만  모두 spin wait를 사용하는 방법으로 lock을 획득하지 못한 스레드는 lock을 얻을 때까지 무한루프를 돌게된다.   
  
무한루프를 도는 것 자체가 cpu 낭비인데 굳이 spin lock을 사용해야할까?   
하드웨어의 지원만으로는 이를 해결할 수 없기에 OS의 지원도 받아 문제를 해결할 수 밖에 없다.  

## 컨디션 변수

하드웨어와 운영체제의 도움으로 락을 만들지만 락 하나로는 병행 프로그램을 지탱할 수 없다.   
스레드의 실행 순서인 동기화를 관리하는 컨디션 변수에 대해 알아보자.     
부모 스레드가 자식 스레드의 작업이 완료되있는지 알기 위해 CPU를 까먹으면서 기다리게되는데   
컨디션 변수를 사용하면 sleep 했다가 깨우면 다시 실행준비에 들어간다.   

### 생산자 소비자 문제

[https://youtu.be/qxPxWRVFKaY](https://youtu.be/qxPxWRVFKaY)

프로그램 상태가 조건과 다를 경우 쓰레드가 대기하도록 하여 컨디션 변수는 동기화 문제를 깔끔하게 해결할 수 있다.  

## 세마포어

![Untitled 3](https://user-images.githubusercontent.com/72185011/175782423-26ce6173-0ed8-4a11-8693-810cf82259f4.png)

병행 프로그램에서 일어나는 문제점을 해결하기 위해서는 락, 컨디션 변수가 필요하다.    
다양한 동기화 문제들을 한방에 해결하고자 세마포어라는 동기화 기법이 등장했다.   
세마포어는 락과 컨디션 변수 모두 사용 가능하다.  

세마포어는 초기값에 의해 동작이 결졍되며 sem_wait과 sem_post 두개의 기능으로 돌아간다.   
기본적으로 세마포어의 값이 1 이상이면 sam wait은 값을 리턴하거나 1이 되기전까지 대기한다  
. sam_post 경우는 기다리지 않고 세마포어의 값을 늘린후 대기중인 쓰레드를 작업에 투입시킨다.   

### 락에 적용한 세마포어(이진 세마포어)


스레드가 2개인 경우를 상상해보자. 스레드 0이 먼저 수행되고 sem_wait()를 수행하여 세마포어 값을 1 감소시킨다.   
sem_wait()는 값이 0보다 작을 때만 sleep 상태로 전환되기 때문에 스레드 0은 바로 임계 영역에 접근하게됨.   

그런 뒤 임계 영역에서의 작업이 끝나면 sem_post()를 호출하여 세마포어 값을 1로 증가시키고.   
물론 여기서 만약 sleep 상태의 스레드가 있다면 그 스레드를 깨워주는 작업도 하게 된다.  

스레드 0이 sem_wait()을 수행한 바로 뒤의 시점인데.   
이 시점에서 만약 다른 스레드가 sem_wait()를 수행하여 임계 영역에 접근하려고 하면 어떻게 될까?  

위와 같이 스레드 0이 sem_wait()를 수행한 뒤 바로 스레드 1이 sem_wait()를 수행하면   
세마포어의 값은 2번 줄게 되어 -1이 된다. 따라서 스레드1의 sem_wait()는 세마포어의 값이 0보다 작기 때문에   
스레드1의 현재 상태를 저장하고 sleep 상태로 전환하게 된다.  

그러다 스레드0이 임계 영역에서의 작업을 끝내고 sem_post()를 수행하면  
세마포어의 값을 1 늘리고 sleep 중인 스레드1을 깨운다.   

그런 뒤 context switch가 되어 스레드1이 실행되면 아까 중단된 시점부터    
시작하게 되고 임계영역으로 접근하게 된다. 임계영역에서의 작업이 끝나면 sem_post()를 수행하게    
되고 세마포어의 값은 초기값과 같은 1로 다시 돌아오게 된다.  

위와 같이 세마포어를 lock과 동일하게 사용할 수 있고 이러한 lock에는 lock을 획득한 상태,   
lock을 해제한 상태의 2가지만 존재하기 때문에 이를 **binary semaphore(이진 세마포어)**라고 합니다.   

이 외에도 컨디션 변수대신  세마포어로 스레드의 실행 순서 관계를 제어할수있고   
생산자 소비자 문제와 철학자의 식사까지 다익스트라는 세마포어를 통해 간단히 해결했다.   

다른 사례로는 쓰레드 통제다. 동시에 스레드가 홍수처럼 쏟아져나와 시스템에 부하를 주게 된다면    
세마포어를 활용하여 스레드의 수가 정해준 최댓값을 넘기지 못하게 막아버릴 수 있다.     
막지못한다면 스레드 생성마다 메모리 할당해야하고 실제 가진 물리 메모리를 넘어 선다면  
메모리를 하드디스크로 옮겨야되는데 여기서 발생하는 오버헤드가 성능에 큰 영향을 준다.    

## 병행 프로그램의 공통적인 문제

동시성은 여러개의 스레드를 동시에 실행할 수 있었고 이때 주의할 점은 공유 자원에 대한 상호 배제와  
스레드 간에 실행 순서를 지켜주는 동기화가 있었다. 이를 위한 Lock, condition variable이 존재.   
이번 글에서는 동시성의 문제점에 대해 알아보자.   

Deadlock이라고 불리는 문제는 잠시 후에 자세히 알아보겠지만 간단히 설명하자면   
그냥 스레드들이 모두 일을 하지 않는 상태를 말한다.   
또한 Deadlock이 아닌 동시성 문제들도 존재하는데 표를 보자.   

![Untitled 4](https://user-images.githubusercontent.com/72185011/175782414-180f910c-a91d-4212-a8aa-e03546a9e9c8.png)


연구 수치로만 보면 데드락 버그보다 데드락 버그가 아닌게 더 많아 보인다,  
대부분 원자성이 안지켜서 일어난 버그들이고 데드락버그를 알아보자.    
복잡한 락 사용하는 병행 프로그램에서는 스레드가 손가락을 쪽 쪽 빨며 기다리는 교착 상태인 데드락이 흔하게 발생한다.  

### 교착 상태는 왜 발생하는가?

한 가지 이유는 코드가 많아지면서 **구성 요소 간에 복잡한 의존성**이 발생하기 때문이   
다. 또 다른 이유는 **캡슐화(encapsulation)**의 성질 때문이다. 소프트웨어 모듈화가   
개발을 쉽게 하기 때문에 소프트웨어 개발자들은 상세한 구현 내용은 감추라고 교육 받았다.     

하지만, 모듈화와 락은 잘 조화되지 않는다.  
전혀 문제 없어 보이는 인터페이스도 교착 상태를 발생시킨다   
예를 들어 자바의 Vector 클래스에서 AddAll() 메소드를 생각해 보자  
이 루틴은 다음과 같은 형식으로 호출될수 있다.   

```java
Vector v1, v2;
v1.AddAll(v2);
```

이 메소드는 멀티 쓰레드에 안전해야 하기 때문에 내부적으로는 v1에 더해지는 벡터뿐만 아니라   
인자로 전달되는 v2에 대한 락도 같이 획득해야 한다.   
이 루틴은 v2 의 내용을 v1에 더하기 위해서 임의의 순서로 말한 락들을 획득하는데,    

여기서는 v1을먼저 획득하고 v2를 획득한다고 하자. 어떤 쓰레드가 v2.AddAll(v1)을 거의 동시에   
호출하면 교착 상태 발생 가능성이 있다. 이 모든 상황은 호출한 응용 프로그램 모르게 진행된다.  

## 교착 상태 발생 조건

교착 상태가 발생하기 위해서는 네 가지 조건이 충족되어야 한다   

- 상호 배제 (Mutual Exclusion): 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인
제어권을 주장한다 (예, 쓰레드가 락을 획득함).  
- 점유 및 대기 (Hold-and-wait): 쓰레드가 자신에게 할당된 자원 (예 : 이미 획득한
락)을 점유한 채로 다른 자원 (예 : 획득하고자 하는 락)을 대기한다.  
- 비 선점 (No preemption): 찐따 쓰레드로부터 자원을 강제로 뺏을수없다.  
- 환형 대기 (Circular wait): 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의
자원 (락)을 갖고 있는 쓰레드들의 순환 고리가 있다.  

이 네 조건 중에 **하나라도 만족시키지 않는다면 교착 상태는 발생하지 않는다**. 먼저 
교착 상태를 예방할 수 있는 기술들을 먼저 살펴보자. 각 전략들은 위의 조건들이  
발생하는 것을 막는다. 그리고 그 전략이 교착 상태를 다루는 방법 중에 하나이다.  

## 교착 상태의 예방

### 순환 대기 (Circular Wait)

아마도 가장 실용적인 교착 상태 예방 기법은 (그리고 자주 사용되는 방법이기도 함)순환 대기  
가 절대 발생하지 않도록 락 코드를 작성하는 것이다.  
가장 간단한 방법은 락획득을 하는 전체 순서를 정하는 것이다.   

예를 들어 L1과 L2라는 두개의 락만이 시스템에 존재하면 L1을 무조건 L2 전에 획득하도록 하면  
교착 상태를 피할수 있다. 이 순서를 따르면 순환 대기는 발생하지 않고 따라서 교착 상태도 발생하지않는다.  

물론, 좀 더 **복잡한 시스템의 경우**, 두 개 이상의 락이 존재할 것이고   
전체 락의 요청순서를 정의하는 것이 **어려울 수 있다** (또는 불필요할 수 있다).       
교착 상태를 피하기위해 부분 순서(partial ordering)를 제공하는 것이 락 획득 구조를 만드는 데 유용할것이다   

전체 또는 부분 순서를 제공하기 위해서는 락 획득 전략을 꼼꼼하게 설계해야 한다.     
더 나아가 순서라는 것은 단순히 관례이기 때문에 떌깜 코드몽키 개발자들이   
이 관례를무시하고 코드를 개발할 경우, 교착 상태가 발생할 수 있다.    

마지막으로 락의 순서를정의하기 위해서는 코드와 다양한 루틴 간의 상호 호출 관계를 이해해야 한다.   
작은실수라 할지라도 교착상태를 만날수있기 때문이다.   

### 점유 및 대기 (Hold-and-Wait)

교착 상태가 발생하는 조건인 점유 및 대기는 **원자적으로 모든 락을 단번에 획득**하도록 하면    
예방할 수 있다 이 해법은 문제점이 많다. 먼저와 같이 **캡슐화**와 관련된 사항이다. **필요한 락들을  
정확히 파악**해야 하고 그 락들을 미리 획득해야 하기 때문이다. 락이 실제 필요할 때   
요청하는 것이 아니라 미리 모든 락을 (단번에) 획득하기 때문에 **병행성이 저하**되는 문제도 있다.  

### 비선점 (No Preemption)

일반적으로 락을 해제하기 전까지는 락을 보유하고 있는 것으로 보기 때문에   
여러 락을 획득하는 것에는 문제의 소지가 있다. 왜냐하면   
락을 이미 보유하고 있는 채로 다른 락을 대기하기 때문이다.    
많은 쓰레드 라이브러리들은 이러한 상황을 피할 수 있도록 유연한 인터페이스 집합을 제공한다.    

trylock() 경우 (획득 가능하다면) 락을 획득하거나 현재 락이 점유된 상태이니     
락을 획득하기 원하면 나중에 다시 시도하라는것을 알리는 -1 값을 리턴한다.    
이 인터페이스 trylock()를 이용하면 교착 상태 가능성이 없고   
획득 순서에 영향을 받지 않는 락 획득 방법을 만들 수 있다    

다른 쓰레드가 같은 프로토콜을 사용하면서 락을 다른 순서 (L2 먼저 L1 그 다음) 로 획득하려고 해도  
역시 교착 상태는 발생하지 않는다. 그렇지만 **무한반복(livelock) 이라는 새로운 문제**가 생긴다.   
두 개의 쓰레드가 이 순서대로 시도하기를 반복하면서 락 획득에 실패하는 것도가능하다.   

두 쓰레드 모두이 코드를 반복 실행하겠지만 (그래서 교착 상태는 아니지만), 실제 진척이 있는 것은  
아니기 때문에 이름대로 무한반복의 상황이다. 무한반복의 문제에 대한 해법도 역시존재한다.    

예를 들면 반복문에 지연 시간을 무작위로 조절하는 것이다.   
그러면 경쟁하는쓰레드 간의 반복 간섭 확률을 줄일 수 있다  

이 해법에 대해 마지막으로 짚고 넘어가야 할 것이 있다.   
이 해법은 trylock()방식의 어려운 부분은 다루지 않고 있다.    
첫 번째 문제는 **캡슐화이다**. 만약 사용하려는락이 호출되는 루틴 깊숙한 곳에 존재한다면  
처음 부분으로 되돌아가도록 구현하는 것이쉽지 않다.   

만약에 코드가 실행 과정에서 (L1이 아닌 다른) 자원을 획득하였다면,   
그자원 역시 반납해야 한다. 예를 들어 L1 획득 후 코드에서 메모리 영역을 할당하였다면   
,L2 획득 실패 시에 처음으로 돌아가서 전체 순서를 다시 시작하기 전에 할당받았던메모리도 같이 반납을 해야 한다.   

하지만, 제한된 경우에만 (예 :자바벡터 메소드) 이러한 접근이 제대로 동작할 것이다  

### 상호 배제 (Mutual Exclusion)

마지막 예방 기법은 상호 배제 자체를 없애는 방법이다  
일반적 코드는 모두 임계 영역을 포함하고 있기 때문에 어려운 일이다.    
그러면 어떻게 해야 할까? Herlihy는 대기없는(wait-free) 자료 구조를 고안했다 

그의 생각은 간단하다.   
락이 필요 없는 강력한 하드웨어 명령어를 사용하여 자료 구조를 만들면된다는 내용이다.  

이와 같은 방식을 사용하면 락을 획득할 필요가 없으며 교착 상태가 발생할 수도 없다  
(무한반복은여전히 발생 가능성이 있기는 하다). 하지만   
대기없는방식으로 삽입과 삭제 그리고 검색을 할 수 있도록 리스트를 만드는 것은 더욱 쉽지않다.    

### 스케줄링으로 교착 상태 회피하기

어떤 시나리오에서는 교착 상태를 예방하는 대신 회피하는 것이 더 유용할 때가 있다       
회피하기 위해서는 실행 중인 여러 쓰레드가 어떤 락을 획득하게 될 것인지에 대해     
전반적으로 파악하고 있어야 하며 그것을 바탕으로   
쓰레드들을 스케줄링하여 교착 상태가 발생하지 않도록 그때그때 보장한다.  

모두 한 프로세서에서 실행되도록 보수적인 방법을 택하기 때문에 전체 작업이 끝나기까지   
상당히 오랜 시간이소요된다. 병행이 가능할 수도 있겠지만,   
교착 상태가 발생할 수 있기 때문에 그렇게 할수 없으며, 어쩔 수 없이 **성능 하락**을 수반한다  

**은행원 알고리즘** (Banker’ s Algorithm)이 있으며 그와 비슷한 방법들도 다수 소개가 되었다.    
상당히 **제한적인 환경에서만 유용**한 방법들이다.      
예를 들어 전체 작업에 대한 모든 지식을 알고 있는   
임베디드 시스템에서 작업을 실행하면서 필요한 락을 획득하는 경우이다.   

더 나아가 이러한 방법들은 두 번째 예에서본 것과 같이 병행성에 제약을 가져 올 수도 있다.  
때문에 스케줄링으로 교착 상태를회피하는 것은 보**편적으로 사용되는 방법은 아니다**  

### 발견 및 복구

교착 상태 발생을 허용하고, 교착 상태를 발견하면 복구 하는 방법이다.   
예를 들어 운영체제가 일 년에 한 번 멈춘다고 했을 때 재부팅을 하고 기분 좋게 처리하는 식이다.   
무식한 방법이 무조건 나쁜건 아니다. 오히려 성능에 좋다.  

많은 데이터베이스 시스템들이 교착 상태를 발견하고 회복하는 기술을 사용한다.   
교착 상태 발견은 주기적으로 자원 할당 그래프를 그려서 사이클이 교착 상태가 생겼는지를  
검사한다. 교착 상태 사이클이 발생하는 경우 시스템은 **재부팅하는 식으로 회복**한다.  

자료구조에 대한 **복잡한 복구**가 필요할 경우, **사람이 직접 복구** 작업을 수행할 수도 있다  

**DON’T ALWAYS DO IT PERFECTLY** **(Tom West’s Law)**  

> 꼭 해야할 모든 일들이 가치가 있는건 아니다. 라는 공학적인 관점에서 명언을 남긴 웨스트 형님  
만약 내가 우주선을 만들고있고 잘못되면 우주선이 폭발하는거 아닌 이상.  
마이너한 결과를 일일으키는 이슈를 잡으려고 시간을 너무 쓰지마라.  
> 

## 곱씹어보자

병행 프로그램에서 발생할 수 있는 오류의 종류중 첫 번째 부류는 논 데드락 오류로서 상당히 흔하지만 대체적으로 고치기 쉬운 오류들이다.  
이 부류는 함께 실행해야 하는 명령어들이 함께 실행이 안되어 발생하는 원자성 위반오류와   
두 쓰레드 간의 실행 순서가 지켜지지 않아 발생하는 순서 위반 오류를 포함한다.  

교착 상태의 발생 원인과 대응방법에대해 살펴보았다. 이 문제는 병행성 문제 자체만큼이나 오래된 것이라 관련 주제에 대해수백 편의 논문들이 소개되었다.   
가장 좋은 해법은 조심하는 것과 락 획득 순서를 정해서애초에 교착 상태가 발생하지 않도록 예방하는 것이다.  

Linux를 포함해서 보편적으로사용되는 라이브러리나 중요한 시스템에서 대기없는 자료 구조가 사용되는 것을 보아 노대기 기법들도 유망해 보인다.   
하지만, 보편성이 부족하고 이 방법은 자료구조를 만드는 것이 복잡하기 때문에 제한적으로 사용될 것으로 보인다.   

최선의 해법은아마도 새로운 병행 프로그래밍 방법론을 만드는 것이다. 구글의 맵리듀 (MapReduce)와 같은 시스템에는   
락을 사용하지 않고도 개발자가 특정한 병렬 연산을 처리할 수 있도록 해준다.   
락은 원천적으로 문제점을 수반하기 때문에반드시 필요한 경우가 아니면 사용을 피하도록 노력해야 한다.
