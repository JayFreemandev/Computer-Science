# 프로세스

프로세스는 뭔가? 실행 중인 프로그램이라고 정의한다. 자바의 정석에서는 프로세스는 공장 스레드는 공장에서 일하는 일꾼으로 비유하곤 했다. 다르게 말하면 프로그램 자체는 생명이 없는 존재다. 

프로그램이란건 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터들의 모임인데. 이 명령어와 데이터 묶음을 읽고 실행하여 프로그램에 생명을 넣어주는것이 운영체제이다.

사용자는 하나 이상의 프로그램을 동시에 실행하고 싶어한다. 인텔리제이를 키면서 크롬도 키고 유튜브에서 음악도 듣고 풍선타워 디펜스도 하고싶어한다. 

컴퓨터는 동시에 여러개의 프로세스를 실행하는것처럼 보인다. 사용 가능한 CPU에 대해 신경쓰지 않고 동시에 여러 프로그램을 실행한다. 어떻게 가능할까?

 

**CPU가 여러 개 존재한다는 환상을 어떻게 줄수있을까?**

물리적인 하나의 CPU를 가지고 있지만 운영체제는 어떻게 무한개의 가까운 CPU 환상을 만들어 내는가? 전능하신 운영체제는 **CPU를 가상화**시킨다. 전에 이야기한 복숭아처럼 먹고 싶어 하는 사람들에게 가상 복숭화를 쥐어준다.

프로세스 하나를 실행하고 좀 있다 중단시키고 다른 프로세스를 다시 실행하는 작업을 반복하면서 하나의 CPU로 마치 여러 CPU가 존재하는듯한 환상을 일으킨다. 

TIME SHARING(시분할)이라고 불리는데 원하는 수 만큼의 프로세스를 동시에 실행하게한다 하지만 CPU를 공유하기에 각 프로세스의 성능은 좋지않다. 모든 현대 운영체제들이 채택하고있는 방법이다.

## 프로세스의 machine state

프로세스의 구성 요소를 이해하기 위해 머신 상태를 알아야한다. 프로그램이 실행되는 동안 머신 상태를 읽어올수있는데 가장 중요한 하드웨어 구성 요소는 무엇이냐? 

바로 메모리다. 명령어는 메모리에 저장되고 실행 프로그램의 데이터 또한 메모리에 저장된다. 

다음은 레지스터다. 많은 명령어들이 레지스터를 직접 읽어온다.  레지스터에도 종류가 있는데 PC라는 레지스터는 프로그램의 어느 명령어가 실행중인지 알려준다. JVM 메모리에도 PC가 존재함. 

스택 포인터와 프레임 포인터라는 레지스터도 있는데 함수의 변수와 리턴 주소를 저장할 스택을 관리할 때 사용하는 레지스터임. 

## 미스테리

![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20a12d08b0ff22445db0338b4173f580ad/Untitled.png)

프로세스가 뭔지 프로그램이 뭔지 간략하게 알았다. 그럼 프로그램이 어떻게 프로세스로 변형되는가? 내부적으로 뭐 어떻게 돌아가고 있는걸까?

프로그램 실행할때 운영체제가 가장 먼저 하는일이 우엇이냐? 바로 저기 디스크에 보이는 정적 데이터와 코드를 메모리와 프로세스 주소공간에 올린다. 

운영체제가 디스크의 해당 바이트를 쪼옥 읽어서 메모리의 어딘가 위에 그림처럼 저장한다는 뜻이다. 초기 운영체제들은 프로그램 실행전에 모두 메모리에 탑재했는데 요즘은 아니다. 최대한 늦춘다. 실행에 필요한 데이터와 코드만 올림.

메모리 올렸으면 이제 스택과 힙을 만들어주면 프로그램 실행 준비는 끝나게된다. 운영체제는 CPU를 새로 생성된 프로세스에게 토스하고 프로그램 실행이 시작된다. 

![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20a12d08b0ff22445db0338b4173f580ad/Untitled%201.png)

프로세스에는 위와 같은 상태들이 존재하고 생성하고 삭제하고 대기하는 API들도 존재한다.  무슨 프로세스가 먼저 시작할지는 운영체제 스케줄링 알고리즘에 따라 결졍된다. 

## 프로세스에서 중요한 자료구조

다수의 프로그램을 동시에 실행할수있도록 프로세스 리스트라는게 존재하는데 이 자료 구조를 이용해서 실행중인 프로그램을 관리하게 된다. 여기서 뺸시한 키워드가 나온다. 프로세스 관리를 위한 정보를 저장하는 자료 구조를 뭐라 하는가? **PCB. Process Control Block**이다.

다시 돌아와서 프로세스 실행 - 중단 반복하면서 CPU 시간을 나눠서 가상화를 구현한다고 했다. 여기에도 문제점이 있는데 CPU를 공유하기때문에 주는 성능저하다. 시스템에 오버헤드 없이 가상화를 구현할수있을까?

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1ecfcf29-0a4a-408a-8abd-7be364ecb425/Untitled.png)

두번째는 제어 문제다. 사나이 운영체제는 CPU와 프로세스를 엄격하게 기강을 잡아야된다. 제어권 뺏기면 운영체제에게 개기려고 하기 때문. 프로세스가 영원히 안꺼지고 OS내부에 접근해서는 안될 정보에 접근한다.

성능 저하와 제어권 기강을 탄탄히 유지하며 운영체제 만드는게 굉장히 챌린지한 도전과제다.
## imited Direct Execution

직역해보자. 제한적인 직접 실행. 이게 무슨 소린가? OS 개발자들이 프로그램 빨리 실행하려고 프로그램을 CPU에서 바로 직접 실행시키는거다. 제일 간단해보이지만 문제를 일으킨다. 

프로그램을 직접 실행하면 프로그램이 OS가 의도한대로 착한일만 할지 누가 아는가 개기려고 들고 OS에 문제를 일으킬수도 있지 않은가? 두번째로는 시분할 해야되는데 직접 CPU에서 돌려버리면 어떻게 프로그램 중단 시키고 다른 프로세스 불러올꺼냐?

이래서 이름이 Limited 라는거다. 프로그램 실행할때 제한을 두지 않으면 OS는 아무것도 제어할수없는 사춘기 소녀 라이브러리다. 운영체제라고 말 할 수 없다.

프로세스를 전환하는 문제점을 보면 여간 까다로운게 아니다. 만약 CPU에서 프로세스가 실행중이면 운영체제에서는 실행중이지 않다라는 뜻이다. 운영체제가 실행하고 있지 않으면 어떻게 전환할수있을까? 못한다. 

### 운영체제는 어떻게 빌려준 CPU를 다시 가져와서 프로세스를 전환할까?

복숭아 빌려줬으면 다시 뻇들어와야 다음 사람한테 쥐어줄수있다.
