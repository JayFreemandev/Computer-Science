# 프로세스

프로세스는 뭔가? 실행 중인 프로그램이라고 정의한다.  
자바의 정석에서는 프로세스는 공장 스레드는 공장에서 일하는 일꾼으로 비유하곤 했다.  
다르게 말하면 프로그램 자체는 생명이 없는 존재다.  

프로그램이란건 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터들의 모임인데.  
이 명령어와 데이터 묶음을 읽고 실행하여 프로그램에 생명을 넣어주는것이 운영체제이다.  

사용자는 하나 이상의 프로그램을 동시에 실행하고 싶어한다.   
인텔리제이를 키면서 크롬도 키고 유튜브에서 음악도 듣고 풍선타워 디펜스도 하고싶어한다.   

컴퓨터는 동시에 여러개의 프로세스를 실행하는것처럼 보인다.    
사용 가능한 CPU에 대해 신경쓰지 않고 동시에 여러 프로그램을 실행한다.   
어떻게 가능할까?    
  
    
      
**CPU가 여러 개 존재한다는 환상을 어떻게 줄수있을까?**  

물리적인 하나의 CPU를 가지고 있지만 운영체제는 어떻게 무한개의 가까운 CPU 환상을 만들어 내는가?    
전능하신 운영체제는 **CPU를 가상화**시킨다.     
전에 이야기한 복숭아처럼 먹고 싶어 하는 사람들에게 가상 복숭화를 쥐어준다.    

프로세스 하나를 실행하고 좀 있다 중단시키고 다른 프로세스를 다시 실행하는 작업을 반복하면서   
하나의 CPU로 마치 여러 CPU가 존재하는듯한 환상을 일으킨다.   

TIME SHARING(시분할)이라고 불리는데 원하는 수 만큼의 프로세스를 동시에 실행하게한다.  
하지만 CPU를 공유하기에 각 프로세스의 성능은 좋지않다.   
모든 현대 운영체제들이 채택하고있는 방법이다.  

## 프로세스의 machine state

프로세스의 구성 요소를 이해하기 위해 머신 상태를 알아야한다.   
프로그램이 실행되는 동안 머신 상태를 읽어올수있는데 가장 중요한 하드웨어 구성 요소는 무엇이냐?   
바로 메모리다. 명령어는 메모리에 저장되고 실행 프로그램의 데이터 또한 메모리에 저장된다.   
  
다음은 레지스터다. 많은 명령어들이 레지스터를 직접 읽어온다.    
레지스터에도 종류가 있는데 PC라는 레지스터는 프로그램의 어느 명령어가 실행중인지 알려준다.   
JVM 메모리에도 PC가 존재함.   
  
스택 포인터와 프레임 포인터라는 레지스터도 있는데 함수의 변수와 리턴 주소를 저장할 스택을 관리할 때 사용하는 레지스터임.   

## 미스테리

![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20a12d08b0ff22445db0338b4173f580ad/Untitled.png)

프로세스가 뭔지 프로그램이 뭔지 간략하게 알았다.   
그럼 프로그램이 어떻게 프로세스로 변형되는가? 내부적으로 뭐 어떻게 돌아가고 있는걸까?  

프로그램 실행할때 운영체제가 가장 먼저 하는일이 우엇이냐?   
바로 저기 디스크에 보이는 정적 데이터와 코드를 메모리와 프로세스 주소공간에 올린다.   

운영체제가 디스크의 해당 바이트를 쪼옥 읽어서 메모리의 어딘가 위에 그림처럼 저장한다는 뜻이다.     
초기 운영체제들은 프로그램 실행전에 모두 메모리에 탑재했는데 요즘은 아니다.  
최대한 늦춘다. 실행에 필요한 데이터와 코드만 올림.  
  
메모리 올렸으면 이제 스택과 힙을 만들어주면 프로그램 실행 준비는 끝나게된다.   
운영체제는 CPU를 새로 생성된 프로세스에게 토스하고 프로그램 실행이 시작된다.   

![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20a12d08b0ff22445db0338b4173f580ad/Untitled%201.png)

프로세스에는 위와 같은 상태들이 존재하고 생성하고 삭제하고 대기하는 API들도 존재한다.    
무슨 프로세스가 먼저 시작할지는 운영체제 스케줄링 알고리즘에 따라 결졍된다.   

## 프로세스에서 중요한 자료구조

다수의 프로그램을 동시에 실행할수있도록 프로세스 리스트라는게 존재하는데 이 자료 구조를 이용해서 실행중인 프로그램을 관리하게 된다.   
여기서 뺸시한 키워드가 나온다. 프로세스 관리를 위한 정보를 저장하는 자료 구조를 뭐라 하는가?  
**PCB. Process Control Block**이다.    

다시 돌아와서 프로세스 실행 - 중단 반복하면서 CPU 시간을 나눠서 가상화를 구현한다고 했다.   
여기에도 문제점이 있는데 CPU를 공유하기때문에 주는 성능저하다.     
시스템에 오버헤드 없이 가상화를 구현할수있을까?    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1ecfcf29-0a4a-408a-8abd-7be364ecb425/Untitled.png)

두번째는 제어 문제다. 사나이 운영체제는 CPU와 프로세스를 엄격하게 기강을 잡아야된다.   
제어권 뺏기면 운영체제에게 개기려고 하기 때문.  
프로세스가 영원히 안꺼지고 OS내부에 접근해서는 안될 정보에 접근한다.  
  
성능 저하와 제어권 기강을 탄탄히 유지하며 운영체제 만드는게 굉장히 챌린지한 도전과제다.  

## Limited Direct Execution

직역해보자. 제한적인 직접 실행. 이게 무슨 소린가?   
OS 개발자들이 프로그램 빨리 실행하려고 프로그램을 CPU에서 바로 직접 실행시키는거다.   
제일 간단해보이지만 문제를 일으킨다.   

프로그램을 직접 실행하면 프로그램이 OS가 의도한대로 착한일만 할지 누가 아는가 개기려고 들고 OS에 문제를 일으킬수도 있지 않은가?   
두번째로는 시분할 해야되는데 직접 CPU에서 돌려버리면 어떻게 프로그램 중단 시키고 다른 프로세스 불러올꺼냐?  
이래서 이름이 Limited 라는거다.  

프로그램 실행할때 제한을 두지 않으면 OS는 아무것도 제어할수없는 사춘기 소녀 라이브러리다.   
운영체제라고 말 할 수 없다.  

프로세스를 전환하는 문제점을 보면 여간 까다로운게 아니다.   
만약 CPU에서 프로세스가 실행중이면 운영체제에서는 실행중이지 않다라는 뜻이다.   
운영체제가 실행하고 있지 않으면 어떻게 전환할수있을까? 못한다.   

### 운영체제는 어떻게 빌려준 CPU를 다시 가져와서 프로세스를 전환할까?

복숭아 빌려줬으면 다시 뻇들어와야 다음 사람한테 쥐어줄수있다.  
평화적으로 **협조**(cooperative) 방식으로 시스템 콜을 기다리는 방법이 있다.   
작업이 지연될거같은 프로세스한테 **믿음으로 가는거지** 마인드로 나도 CPU 써야되니까 틈 날때마다 시스템 콜해서 돌려줘라는 방법이다.   
매킨토시 초기버전이나 오래전 운영체제에서는 이렇게 썼다.  

믿음으로 가는거지만 가끔 믿음을 깨버리는 악동 프로세스들이 악의적은 용도로 문제를 일으킬수도있다. 현대 운영체제에서는 바로 종료 시킨다. 단 한번의 기회도 주지않고 깝치는 프로세스는 한 번에 정리한다. 만약 메모리에 불법적인 접근이나 명령어가 실행된다면 운영체제는 어떻게 해야할까?

예를 들어 어떤 수를 0으로 나눈다거나 이상한짓을 하면 그때는 시스템콜을 안기다리고 CPU를 다시 뺏어온다. 그렇다면 의도한게 아닌 버그가 일어난 거라면 프로세스는 무한 루프에 빠지게되서 시스템콜을 할수가없다. 이럼 어떻게 해야하는가?

방법은 **재부팅**이다. 옛날 부터 재부팅은 최고 존엄 문제해결 방법이였다. 재부팅이 아니고서야 운영체제는 손가락을 쪽쪽빨며 영원히 돌아오지않을 무한루프속 CPU를 기다려야한다. 

그렇다고 일자 무식한 방법은 아니다. 재부팅은 오래된 자원이나 제어할수없는 자원을 시스템에 반환한다. 대규모 서비스에서는 컴퓨터 일부를 주기적으로 재부팅한다. 오히려 시스템 성능 향상에 좋기 때문이다.

### 비협조적인 악동 프로세스에게 컴퓨터를 뺏기지 않으려면?

![time-to-stop-lol.gif](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5da5c0f9-d366-4aa3-8784-6562b51cc45c/time-to-stop-lol.gif)

해결책은 수십년전에 발명되었다. “**타이머 인터럽트**” 밀리초마다 타이머 장치는 인터럽트를 발생시킨다. 인터럽트가 발생하게되면 현재 실행중인 프로세스는 멈추고 마법카드인 **인터럽트 핸들러**가 발동한다. 

찐따같던 운영체제는 CPU를 다시 돌려받고 다른 프로세스를 실행시키게된다. 타이머 인터럽트 하드웨어 기능은 찐따같은 운영체제가 컴퓨터의 제어를 유지하는 근본적인 방법이다.

CPU를 돌려 받았으면 다음은 어떤 행동을 할지, 행동이란 이 프로세스를 중단 시킬지 말지 다음 프로세스에게 CPU를 줄지 말지의 행동이다. 이건 **스케줄러**가 결정하고 프로세스를 넘기려고 결정하면 **Context Switch**를 실행한다.

Context Switch를 간단하게 설명하자면 현재 실행중인 프로세스의 레지스터 값을 스택에 저장하고 다음 프로세스 스택으로부터 레지스터값을 리턴받는다. 

### 만약 시스템콜 도중 타이머 인터럽트가 발생한다면?

혹은 인터럽트를 처리하고 있는데 다른 인터럽트가 발생하면? 운영체제는 눈빛이 돌변하며 “동작 금지”를 외친다. 지금 인터럽트가 진행중이면 어떠한 인터럽트도 CPU에 전달되지 않는다. 

인터럽트를 너무 오랫동안 동작 금지시켜도 문제가 생기고 시스템 내부적으로 접근 방지를 위한 “Lock” 기술이 등장했다. 다음 챕터에서 설명할거지만 Lock으로 인해 까탈스러운 버그또한 등장했다.
