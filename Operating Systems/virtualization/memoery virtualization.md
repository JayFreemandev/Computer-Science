# Memory 가상화

## 메모리 가상화

CPU에서 가상화가 이루어지는것에 대해 배웠다. CPU는 간단했지만 메모리의 가상화 경우는 운영체의 상호작용과 하드웨어에 대한 이해가 필요하다. 프로그램이 생성하는 모든 주소는 가상주소이다. 계속 언급했던것처럼 운영체제는 “일루전”, 프로세스에게 환상을 보여준다. 

프로세스는 자신이 엄청 거대한 전용 메모리를 얻었다고 생각한다. 운영체제가 눈속임하면 이제 하드웨어에서는 현대백화점 상품권을 현금으로 바꿔주는것마냥 가상 주소를 실제 물리 주소로 변환시키고 목표하는 정보가 담겨있는 위치를 찾아낸다.

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled.png)

**운영체제가 이렇게 프로세스에게 환상을 보여주는 이유는 무엇일까?**

프로그래머에게 쉬운 시스템을 제공하기 위해서이다. 각 프로세스에게 거대하고 연속된 주소 공간의 환상을 만들어 버리면 프로그래머는 해당 변수를 어느 위치에 저장할지에 대한 노력을 할 필요가 없다. 만약에 운영체제가 이런 환상을 프로세스에게 주지않았더라면 빽빽하고 좁은 공간에 데이터를 어느 위치에 넣을지는 개발자의 몫이 될것이다.

다른 이유로는 isolation과 protection이다. A 프로그램이 B 프로그램의 메모리를 읽고 잘못된 데이터를 덮어쓰거나 수정하는거를 막기위한 이유이기도 하다.

주소 공간(Address Space)

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%201.png)

옛날 컴퓨터들의 물리 메모리 그림을 보면 하나의 프로그램(프로세스)가 있고 나머지 메모리를 사용한다. 가상화도 없고 별로 특별한게 없던 시절이라 개발자는 꿀을 빨수 있었다.

모든 고난의 길은 사용자 편의성과 고성능, 안정성을 사용자들이 원하기 시작한 후다.  컴퓨터는 비싼 장비였기에 효율적으로 컴퓨터를 공유하기 위해 멀티프로그래밍이 등장한다. 

여러 프로세스를 올려놓고 운영체제는 빠르게 프로세스들을 전환해가며 CPU의 효율을 높였다. 더 많은 사람들이 컴퓨터 사용을 원하자 Time Sharing이 등장했다. 사용자들이 동시에 사용하며 현재 작업의 응답을 바로 받을수있는 Interactivity, 마치 대화를 하는듯한 방법을 사용하였다.

이상적으로 보이는 Time sharing의 큰 결함이 존재했는데 운영체제가 프로세스에게 생명을 불어넣는순간 모든 메모리 접근 권한을 가지게된다 다른 프로세스로 전환되기전에 모든 상태 정보들을 메모리에 저장하고 턴을 마치게 되는데 단순 레지스터 상태를 저장하고 다시 불러오는거는 빠르지만 메모리 전체 내용을 디스크에 저장하는게 매우 매우 느리다. 다른 프로세스 전환마다 그러면 이건 쓸 수 없는 방법이 되버린다. 

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%202.png)

프로세스 전환할때 메모리를 그대로 프로세스에 유지하기 위한 상황이 다. 512KB 메모리에 프로세스 3개가 들어있다. 프로세스 A가 실행중일때 B,C는 큐에서 대기하게된다. 

이렇게 여러 프로그램이 하나의 메모리를 공유하면서 존재하려면 proection의 문제가 부곽되게된다. 갑자기 B,C 프로세스에서 A메모리 읽고 데이터까지 수정 변경되어 저장된다면 이건 심각한 상황이다.

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%203.png)

## 메모리 가상화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c08dde42-4375-423c-80c7-980620022683/Untitled.png)

개노답 프로세스 삼형제들에게 이런 상황을 보지않기위해 운영체제는 프로세스에게 환상을 심어준다, 메모리 가상화이다. 마치 개노답 삼형제들은 본인이 특정한 위치에 엄청난 크기의 전용 메모리를 가지게된다고 생각하지만 실제로는 하드웨어의 도움을 받아 가상주소를 물리주소로 변환시키며 가상화 데이터를 끄집어 내게된다. 

메모리를 가상화 하기위한 조건이 몇가지 존재한다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/57c2fd2d-77ca-4fcd-b5a9-ce2c21b2a448/Untitled.png)

### Isolation

바로 Isolation 이다. 튼튼한 시스템을 만드는데 가장 중요한 핵심이다. 프로세스가 운영체제에게 기어오르는걸 막아야한다. 한 프로세스가 다른 프로세스에게 피해를 줘소도 안되고 운영체제 동작에 문제를 일으켜서도 안된다. 

### transparency

프로세스의 눈을 속여라 본인들이 찐 물리주소를 가지고있다고 착각해야 더 많은 내용을 공유할수있다. 

### efficiency

그렇다고 가상화를 위해 너무 많은 메모리를 사용하면 느려진다. 하드웨어의 도움도 필요하니 적절하게 섞어 효율적이게 가상화시켜야한다.

### protection

운영체제는 프로세스가 다른 프로세스 영향주는것도 막아야하고 본인도 프로세스가 깝치는걸 막아야한다.

우리가 코드로 주소를 출력하면 0x108529afe20같은 주소가 나오게되는데 우리가 볼수있는 주소는 모두 가상주소다. 찐 물리 메모리 주소는 운영체제와 하드웨어만이 알수있다.
