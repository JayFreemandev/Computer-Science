## 메모리 가상화

CPU에서 가상화가 이루어지는것에 대해 배웠다.   
CPU는 간단했지만 메모리의 가상화 경우는 운영체의 상호작용과 하드웨어에 대한 이해가 필요하다.   
프로그램이 생성하는 모든 주소는 가상주소이다.   
계속 언급했던것처럼 운영체제는 “일루전”, 프로세스에게 환상을 보여준다.   

프로세스는 자신이 엄청 거대한 전용 메모리를 얻었다고 생각한다.   
운영체제가 눈속임하면 이제 하드웨어에서는 현대백화점 상품권을 현금으로 바꿔주는것마냥   
가상 주소를 실제 물리 주소로 변환시키고 목표하는 정보가 담겨있는 위치를 찾아낸다.  

![Untitled](https://user-images.githubusercontent.com/72185011/175781420-483a3e57-5564-4494-bdf9-94d454426c2d.png)

**운영체제가 이렇게 프로세스에게 환상을 보여주는 이유는 무엇일까?**

프로그래머에게 쉬운 시스템을 제공하기 위해서이다.   
각 프로세스에게 거대하고 연속된 주소 공간의 환상을 만들어 버리면   
프로그래머는 해당 변수를 어느 위치에 저장할지에 대한 노력을 할 필요가 없다.   
만약에 운영체제가 이런 환상을 프로세스에게 주지않았더라면   
빽빽하고 좁은 공간에 데이터를 어느 위치에 넣을지는 개발자의 몫이 될것이다.  

다른 이유로는 isolation과 protection이다.   
A 프로그램이 B 프로그램의 메모리를 읽고 잘못된 데이터를   
덮어쓰거나 수정하는거를 막기위한 이유이기도 하다.  

주소 공간(Address Space)

![Untitled 1](https://user-images.githubusercontent.com/72185011/175781426-a0d76343-6c90-4d36-a473-24427ef8fabb.png)


옛날 컴퓨터들의 물리 메모리 그림을 보면 하나의 프로그램(프로세스)가 있고   
나머지 메모리를 사용한다. 가상화도 없고 별로 특별한게 없던 시절이라 개발자는 꿀을 빨수 있었다.  

모든 고난의 길은 사용자 편의성과 고성능, 안정성을 사용자들이 원하기 시작한 후다.   
컴퓨터는 비싼 장비였기에 효율적으로 컴퓨터를 공유하기 위해 멀티프로그래밍이 등장한다.   

여러 프로세스를 올려놓고 운영체제는 빠르게 프로세스들을 전환해가며 CPU의 효율을 높였다.   
더 많은 사람들이 컴퓨터 사용을 원하자 Time Sharing이 등장했다.   
사용자들이 동시에 사용하며 현재 작업의 응답을 바로 받을수있는 Interactivity,   
마치 대화를 하는듯한 방법을 사용하였다.  

이상적으로 보이는 Time sharing의 큰 결함이 존재했는데 운영체제가   
프로세스에게 생명을 불어넣는순간 모든 메모리 접근 권한을 가지게된다    
다른 프로세스로 전환되기전에 모든 상태 정보들을 메모리에 저장하고 턴을 마치게 되는데     

단순 레지스터 상태를 저장하고 다시 불러오는거는 빠르지만 메모리 전체 내용을    
디스크에 저장하는게 매우 매우 느리다.    
다른 프로세스 전환마다 그러면 이건 쓸 수 없는 방법이 되버린다.   

![Untitled 2](https://user-images.githubusercontent.com/72185011/175781428-f8766c4d-51ee-4f2a-956f-6c91255a323c.png)

프로세스 전환할때 메모리를 그대로 프로세스에 유지하기 위한 상황이다.  
512KB 메모리에 프로세스 3개가 들어있다. 프로세스 A가 실행중일때 B,C는 큐에서 대기하게된다.   

이렇게 여러 프로그램이 하나의 메모리를 공유하면서 존재하려면 proection의 문제가 부곽되게된다.   
갑자기 B,C 프로세스에서 A메모리 읽고 데이터까지 수정 변경되어 저장된다면 이건 심각한 상황이다.  

## 메모리 가상화

![Untitled 3](https://user-images.githubusercontent.com/72185011/175781431-bcc7877e-c43a-48da-b4f1-e0960a3aae92.png)


개노답 프로세스 삼형제들에게 이런 상황을 보지않기위해 운영체제는 프로세스에게 환상을 심어준다,   
메모리 가상화이다. 마치 개노답 삼형제들은 본인이 특정한 위치에 엄청난 크기의  
전용 메모리를 가지게된다고 생각하지만 실제로는 하드웨어의 도움을 받아   
가상주소를 물리주소로 변환시키며 가상화 데이터를 끄집어 내게된다.     

메모리를 가상화 하기위한 조건이 몇가지 존재한다.   

![Untitled 4](https://user-images.githubusercontent.com/72185011/175781432-708fce5a-8b5a-4165-9d57-64e7c7d9f660.png)


### Isolation

바로 Isolation 이다. 튼튼한 시스템을 만드는데 가장 중요한 핵심이다.  
프로세스가 운영체제에게 기어오르는걸 막아야한다.   
한 프로세스가 다른 프로세스에게 피해를 줘소도 안되고 운영체제 동작에 문제를 일으켜서도 안된다.    

### transparency

프로세스의 눈을 속여라 본인들이 찐 물리주소를 가지고있다고 착각해야 더 많은 내용을 공유할수있다. 

### efficiency

그렇다고 가상화를 위해 너무 많은 메모리를 사용하면 느려진다.   
하드웨어의 도움도 필요하니 적절하게 섞어 효율적이게 가상화시켜야한다.  
 
### protection

운영체제는 프로세스가 다른 프로세스 영향주는것도 막아야하고 본인도 프로세스가 깝치는걸 막아야한다.  
우리가 코드로 주소를 출력하면 0x108529afe20같은 주소가 나오게되는데 우리가 볼수있는 주소는 모두 가상주소다.   
찐 물리 메모리 주소는 운영체제와 하드웨어만이 알수있다.   
  
### 어떻게 효율이면서 유연하게 메모리 가상화를 시킬까?

이전에 CPU 가상화 설명하면서 나온 limited 실행을 떠올려보면  
거기의 연장선으로써 하드웨어를 사용하여 가상 주소를 실제 물리 주소로 변환하는 **주소 변환** 방법이 있다.   

하드웨어가 알아서 뚝 딱 주소 변환시켜주는게 아니라 운영체제가 중간에 나서서   
메모리의 사용 공간이 비었는지 아닌지 제어하고 난 후 하드웨어를 사용한다.  

첫번째 시도는 민망할정도로 간단하게 시작한다. 여기서 가정을 한번 해보자.   
주소 공간이 물리 메모리에 연속되게 저장되어야된다 치자.    
당연히 주소 공간 크기가 작다고 가정해야되고 물리 메모리의 주소 공간또한   
동일하다는 비현실적인 가정을 지은채로 현실적으로 바꾸면서 풀어보자.  

time sharing에서는 base and bound라는 방법이 선택되었다.   
동적 배치라고도 말하는데 CPU는 2개의 하드웨어 레지스트리를 요구한다 그게 BASE랑 BOUND다.   

![Untitled 5](https://user-images.githubusercontent.com/72185011/175781437-5e175226-91b3-4a41-8e02-240826ce71f9.png)


Base와 Bound는 프로세스가 자기 주소에만 접근할수있게 도와준다.   
프로그램이 시작하면 운영체제는 물리 메모리 주소를 결정해주고 베이스 레지스터를 결정한 주소값으로 세팅한다.  
프로세스에서 생성되는 모든 주소는 다음과 같이 변환될거다.   
가상주소에서 base를 더한 값이 찐 물리주소다.   

```java
physical address = virtual address + base
```

동적 재배치라고 불리는 이유도 프로그램 시작할때부터 계속 주소 공간을    
이동시킬수있는데 이전 운영체제를 보면 정적 재배치라고 하드웨어 도움없이   
소프트웨어로 메모리 주소 할당해주다가 피를 보았기 때문이다.   

다른 프로세스나 운영체제 메모리 마음만 먹으면 넘나들수도있고     
한번 배치후에 재배치가 까다로워서 현대 OS는 동적 재배치를 사용한다.   
그런데 base bound라면서 bound는 어디있는가?   

bound는 레지스터를 보호하는 기능을 가지고있다. 
16KB로 설정된 바운드의 크기는 프로세스가 바운드보다 크거나   
음수인 주소에 접근시도할때 CPU는 예외를 터트리고 종료된다.   

이러한 하드웨어의 도움을 통해 잘못된 접근을 막고 모든 메모리 접근 권한을   
제어하는 운영체제는 올바른 값으로의 주소 접근을 허용시킨다.      
하지만 이런 동적 재배치는 큰 물리 메모리공간에 박혀있는 프로세스 스택과 힙이   
작기때문에 빈 공간의 차이가 크게 생긴다. 이런걸 **메모리 내부 단편화**라고 한다.  

메모리에 프로세스를 더 넣을수있는데도 고정된 크기로 넣어야해서 메모리 단편화를 겪게된다.  
base&bound의 효율성을 가지며 이걸 해결하기위해 **세그멘테이션**이 등장한다.  

## 세그멘테이션

32비트 기준 가상공산이 4GB가 되는데 고작 몇 메가바이트 사용하려고 주소 공간을 통으로 메모리에 넣는거는 미친짓이다.  
메모리의 크기보다 큰 프로세스는 실행도 못할거다.     
세그멘테이션은 이런 비효율적인 단편화를 해결하기위해 6.25시절에 나온 아이디어다.     

CPU MMU안에 base bounce 레지스터 하나 말고 얘들을 한쌍으로 메모리의   
부분적이게 표현하는게 어떨까? 이 부분을 segment라고 부르며 code, stack, heap으로 구성되어있다.   

![Untitled 7](https://user-images.githubusercontent.com/72185011/175781444-efacc007-43ea-4e1c-aa8a-1cacf13cc71c.png)
![Untitled 6](https://user-images.githubusercontent.com/72185011/175781445-9a1d8fbb-3af4-4a89-9a66-d01831d37692.png)


차이가 보이는가? 왼쪽은 주소변환해서 생긴 단편화의 크기를 세그먼트를 사용하면 오른쪽과 같다.  
16kb는 운영체제로 쓰고 실제 사용중인 공간에만 물리 공간이 할당된다  
heap과 stack사이에 공간이 낭비되지않는다.    

메모리 절약을 위해 heap stack code중 **code를 공유**하는것이 일반적이다   
왜냐하면 동일한 프로그램이면 CODE부분이 동일하기 떄문이다. 현대 OS에서도 채택한 내용이다.   
물론 운영체제는 공유에대한 protection지원이 필요하다.   
]프로세스는 자기만의 공간만 있는줄알지만 뒤로는 운영체제가 메모리를 공유시킨다.   

## OS Support

세그멘테이션을 통해 주소 변환을 할때 OS가 지원해야할 사항은 뭐가 있을까?

1. Context Switch

세그먼트의 레지스터 값들을 저장하고 다른 프로세스에서 리턴해주며 전환시킨다.

1. Segment 개수의 증가와 감소에따른 문제

C언어 기준 malloc으로 메모리 할당을 하는데 Heap에서 받아 처리할때 공간이 있어서   
해당 주소값 포인터 리턴해주면 다행이지만 공간이 없으면 Segment자체를 늘려야한다.   
heap을 강제로 늘리기 위해 시스템콜을 사용하게되는데 진짜 물리 메모리에   
공간이 없어서 heap도 못늘려주는거면 OS는 예외로 터트려야한다.   

1. 실제 물리 메모리 관리

가상 주소 공간이 생성되면 실제로 물리 메모리 어디에 넣을건지 OS가 공간을 찾아줘야되는데    
프로세스마다 크키도 세그먼트의 크기도 다르다. 만약 너무 큰 공간에 작은 세그먼트를 넣으면  
공간이 너무 낭비가되고 비효율적이게 된다. **외부 단편화 현상**이라한다.  

![Untitled 8](https://user-images.githubusercontent.com/72185011/175781450-4c1a2d98-d1b0-47e8-acd7-843bdddc5b0d.png)


왼쪽에 20KB 세그먼트를 할당하려고하는데 왼쪽 안쓰는 공간을 다 합쳐보면 24KB가 나오긴한다  
하지만 연속적으로 20KB를 가지는 공간은 보이지않아서 OS는 공간이 있음에도 할당을 해줄수가없다.   
이때 메모리를 압축시켜버리는게 오른쪽 예시이다.   

압축하는 방법또한 비용이 많이 드는 방법인데 메모리 여유 공간을 관리하는  
free list management algorithm을 사용할수도 있지만 좀 더 비용이 작아지는거지   
세그먼트를 통한 외부 단편화를 근본적으로 해결할수는 없다.   

기존에 가상 주소 변환(동적 재할당)을 base&bound 한쌍의 레지스터를 연속된 메모리에 통채로 
박아넣어 생기던 heap 과 stack 사이의 빈 공간을 세그멘테이션으로 해결할수있었고   
동일한 프로그램경우는 code 영역을 공유시켜 메모리를 효율적 사용하게 할수도있었다.  

하지만 세그먼트는 고정된 크기가 아니기때문에 외부 단편화가 발생할 수 밖에 없더라.  

## 페이징

메모리를 가변적인 크기로 분할하는 세그멘테이션 대신     
고정적인 크기로 분할하는 페이징이라는 기법이 등장했다.   
고정 크기 단위를 페이지라 부르며 이 페이지 프레임 하나는 가상 메모리 하나를 저장하게된다.     

## 페이징에 관한 의문점

세그멘테이션의 문제를 해결하기위해 페이징은 어떻게 가상화시키는가?

어떤 방법을 사용하는가?

적은 비용으로 극한의 효율을 뽑으려면 어떻게 해야하는가?

![Untitled 9](https://user-images.githubusercontent.com/72185011/175781454-bf05320e-4b24-4f01-97d3-4daa272af2d0.png)


간단한 예시를 들어보자. 총 크기 64바이트, 16바이트 4개 페이지로 이루어진 주소 공간을 그려봐라.   
실제 주소 공간은 32비트 기준 4GB, 64비트 기준은 매우 거대하다.  
32비트 주소를 테니스 코트장이라고 치면 64비트의 주소공간은 유럽크기로 생각하면 편하기에 64바이트로 작게 잡고 간다.  

![Untitled 10](https://user-images.githubusercontent.com/72185011/175781455-91a80ca4-440d-457f-9d02-568d78a3b563.png)


128바이트 물리 메모리를 16바이트 8개로 쪼갠 그림이다.   
세그멘테이션을 사용했을때의 힙과 스택의 확장 방향을 고려하여야됬고 빈 공간을 체크했어야됬는데   
페이징을 사용할때는 프로세스 크기에 맞게 물리 메모리에 꼽으면 된다. **외부단편화 해결**과 유연한 **메모리할당**을 보장한다.  

### 페이지 테이블

위에 페이지들이 물리 메모리 어디에 위치하는지를 알려면 **페이지 테이블**을 알아야한다.   
세그멘테이션에서 사용하던 base&bound 쌍들보다 크기가 더 클수도있다.   
페이지 정보를 담은 테이블 크기가 4바이트, 프로세스 100개가 사용한다하면 400MB까지 올라간다.  
이걸 CPU 레지스트리에는 저장못함. OS 가상 메모리에 집어넣어서 관리한다.  
<br>
위에 말했다 싶이 **페이지 테이블이란 가상 주소를 실제 물리 주소로 변환시키는 자료구조**이다.   
윈도우 메모리도 많이 사용하고 변환방법도 세그멘테이션에 비해 복잡하기때문에 **속도면에서 느리다**고 할수있다.   
<br>
주소 변환에서 오는 속도 이슈를 해결하기 위하여 하드웨어에서 도움을 받는다.   
TLB를 주소 변환 캐시로 사용해서 대부분의 참조값들은 메인 메모리에 페이지 테이블을 거치지않고 빠르게 접근하게 만들었다.   
물론 짧은 시간 동안 접근하는 페이지들이 TLB 범위를 넘어선다면 TLB 미스라는게 발생하여 속도를 느리게 만들것이다.  
<br>
그러면 더 큰 페이지를 사용하면 범위도 늘어나서 TLB 미스도 비껴갈꺼지않을까?   
물론 데이터베이스 관리 시스템에서는 이러한 방법이 적용되었다.   
하지만 페이지 크기가 증가하게되면 **내부 단편화**라는 부작용을 발생시킨다.  


내부 단편화를 할당 페이지 내부에서 자원의 낭비라고도 표현하는데.    
배보다 배꼽이 더 큰 응용 프로그램들이 페이지를 할당받지만 결국 할당받는 페이지의   
일부분만을 사용해서 큰 시스템일 경우 메모리를 큰 페이지들이 창내게된다.   

## 하이브리드

![Untitled 11](https://user-images.githubusercontent.com/72185011/175781456-d878a5d8-ea4d-4f6e-b309-45701d6c6855.png)

그냥 페이징과 세그멘테이션을 잘 섞어서 페이지 테이블크기 줄여서 사용하자라는 의견이 나왔다.  
프로세스 전체 주소 공간을 하나의 페이지 테이블에 넣고 세그먼트마다 페이지테이블을 만들어주면 어떨까?  

주소 공간에서 특정한 패턴을 요구하는 세그먼트덕에 여전히 유연하지못했고 큰 공간을 커버할수있지만    
띄엄 띄엄 사용되는 힙또한 페이지 테이블 낭비를 불러일으켰다.    
외부단편화를 해결할수없었으며 메모리 상에서 페이지테이블용 공간 확보하는게 너무 어렵다는게 현실적인 이유로 다가왔다.  

해결 하기 위해 여러 다양한 멀티 레벨 페이지 테이블이라던가 여러 자료구조들이 나왔지만 항상 창과 방패와 같은 장단점을 가지고있었다.     
내가 주어진 상황에 맞게 선택해야하는게 맞다. 옛날이야 주기억 장치 용량이 작아서 소형 자료 구조를 사용하고   
큰 테이블 그냥 사용해서 TLB 미스 줄이는게 맞았다. 소프트웨어로 관리되는 TLB는 개발자가 자료구조 만들수있어서 좋은 상황이다.  

## 물리 메모리의 극복

![Untitled 12](https://user-images.githubusercontent.com/72185011/175781459-1fe0c87e-94e7-4988-a022-d3d96b546a3f.png)


모든 예시는 메모리의 크기보다 작은 프로세스의 경우만 설명했다.    
하지만 실제 프로그램에서는 그렇다면 만약 메모리의 크기보다 큰 프로세스를 실행하려면 어떻게 해야 할까?   
지금까지는 모든 페이지들이 메모리에 있다고 가정했는데 메모리보다 더 큰공간이 필요하다. 바로 **하드디스크에** 저장한다.   
  
어떻게 실제 물리 메모리는 정해져있는게 OS는 프로레스에게 구라를 칠수있을까? 

![Untitled 13](https://user-images.githubusercontent.com/72185011/175781464-48073ee4-14d2-4596-94c9-35e2644b06a9.png)


page를 메모리가 아닌 하드디스크에 저장할 수 있는데 이렇게 page가 저장되는 디스크 공간을 swap 공간이라고 한다.   
메모리를 보면 프로세스 0,1,2는 실제 메모리에 올라가있지만 밑에 3은 보이지 않는다.    
프로세스 3은 페이지가 디스크로 스왑 아웃되있는걸 볼 수 있다.   
<br>
Block2를 보면 스왑 공간에 하나가 비어있는데 저런 빈 공간들을 이용해서 시스템에 실제 물리적으로  
존재하는 메모리 공간보다 더 큰 공간이 존재하는 것처럼 환상을 일으킨다.
만약 교체해야되는데 메모리에 공간이 없다?   
<br>
이런 공간을 만들기 위해서 present bit과 복잡한 페이지 테이블 구조들이 사용되는데  
이 모든 일련의 작업들은 프로세스가 알아차리기 전에 처리된다.   

현대에 오면서 페이지 알고리즘에 대한 중요성은 낮아졌다.     
메모리 접근 시간과 디스크 접근 시간의 차이는 증가했고 디스크에 페이징하려는 비용이 더 큰 상황이기때문이다.   
잦은 페이징은 너무 큰 비용을 요구한다. 현대의 해결책은 다음과 같다. “**그냥 DRAM 메모리 더 끼워라**”   

### 마지막으로 다시 상기해보자

이번 메모리 가상화에서 가장 핵심은 TLB다. 주소 변환을 위한 캐시를 지원한다.   
페이지 테이블은 크기가 크기때문에 크고 느린 메모리에 살고있는데.   
TLB로 인해서 가상 메모리가 작동하고 범위를 체크해서 올바른 범위내에 메모리를 할당한다.  

시스템 초기에 base bound 레지스터를 이용한 메모리 할당은 유연하지못했다.   
주소 변환을 하는 자료구조는 개발자의 역량에 따라 사용자들이 사용할수있게 충분히 유연하게 제공해줘야한다.   
예를 들어 사용자가 주소 공간이 필요할때만 테이블에 공간을 생성해주는 멀티레벨 테이블같은 자료구조이다.  
