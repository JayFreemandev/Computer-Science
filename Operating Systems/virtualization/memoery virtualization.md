# Memory 가상화

## 메모리 가상화

CPU에서 가상화가 이루어지는것에 대해 배웠다. CPU는 간단했지만 메모리의 가상화 경우는 운영체의 상호작용과 하드웨어에 대한 이해가 필요하다. 프로그램이 생성하는 모든 주소는 가상주소이다. 계속 언급했던것처럼 운영체제는 “일루전”, 프로세스에게 환상을 보여준다. 

프로세스는 자신이 엄청 거대한 전용 메모리를 얻었다고 생각한다. 운영체제가 눈속임하면 이제 하드웨어에서는 현대백화점 상품권을 현금으로 바꿔주는것마냥 가상 주소를 실제 물리 주소로 변환시키고 목표하는 정보가 담겨있는 위치를 찾아낸다.

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled.png)

**운영체제가 이렇게 프로세스에게 환상을 보여주는 이유는 무엇일까?**

프로그래머에게 쉬운 시스템을 제공하기 위해서이다. 각 프로세스에게 거대하고 연속된 주소 공간의 환상을 만들어 버리면 프로그래머는 해당 변수를 어느 위치에 저장할지에 대한 노력을 할 필요가 없다. 만약에 운영체제가 이런 환상을 프로세스에게 주지않았더라면 빽빽하고 좁은 공간에 데이터를 어느 위치에 넣을지는 개발자의 몫이 될것이다.

다른 이유로는 isolation과 protection이다. A 프로그램이 B 프로그램의 메모리를 읽고 잘못된 데이터를 덮어쓰거나 수정하는거를 막기위한 이유이기도 하다.

주소 공간(Address Space)

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%201.png)

옛날 컴퓨터들의 물리 메모리 그림을 보면 하나의 프로그램(프로세스)가 있고 나머지 메모리를 사용한다. 가상화도 없고 별로 특별한게 없던 시절이라 개발자는 꿀을 빨수 있었다.

모든 고난의 길은 사용자 편의성과 고성능, 안정성을 사용자들이 원하기 시작한 후다.  컴퓨터는 비싼 장비였기에 효율적으로 컴퓨터를 공유하기 위해 멀티프로그래밍이 등장한다. 

여러 프로세스를 올려놓고 운영체제는 빠르게 프로세스들을 전환해가며 CPU의 효율을 높였다. 더 많은 사람들이 컴퓨터 사용을 원하자 Time Sharing이 등장했다. 사용자들이 동시에 사용하며 현재 작업의 응답을 바로 받을수있는 Interactivity, 마치 대화를 하는듯한 방법을 사용하였다.

이상적으로 보이는 Time sharing의 큰 결함이 존재했는데 운영체제가 프로세스에게 생명을 불어넣는순간 모든 메모리 접근 권한을 가지게된다 다른 프로세스로 전환되기전에 모든 상태 정보들을 메모리에 저장하고 턴을 마치게 되는데 단순 레지스터 상태를 저장하고 다시 불러오는거는 빠르지만 메모리 전체 내용을 디스크에 저장하는게 매우 매우 느리다. 다른 프로세스 전환마다 그러면 이건 쓸 수 없는 방법이 되버린다. 

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%202.png)

프로세스 전환할때 메모리를 그대로 프로세스에 유지하기 위한 상황이 다. 512KB 메모리에 프로세스 3개가 들어있다. 프로세스 A가 실행중일때 B,C는 큐에서 대기하게된다. 

이렇게 여러 프로그램이 하나의 메모리를 공유하면서 존재하려면 proection의 문제가 부곽되게된다. 갑자기 B,C 프로세스에서 A메모리 읽고 데이터까지 수정 변경되어 저장된다면 이건 심각한 상황이다.

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%203.png)
