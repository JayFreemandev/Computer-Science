# Memory 가상화

## 메모리 가상화

CPU에서 가상화가 이루어지는것에 대해 배웠다.  
CPU는 간단했지만 메모리의 가상화 경우는 운영체의 상호작용과 하드웨어에 대한 이해가 필요하다.   
프로그램이 생성하는 모든 주소는 가상주소이다. 계속 언급했던것처럼 운영체제는 “일루전”, 프로세스에게 환상을 보여준다. 

프로세스는 자신이 엄청 거대한 전용 메모리를 얻었다고 생각한다.   
운영체제가 눈속임하면 이제 하드웨어에서는 현대백화점 상품권을 현금으로 바꿔주는것마냥 가상 주소를 실제 물리 주소로 변환시키고 목표하는 정보가 담겨있는 위치를 찾아낸다.

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled.png)

**운영체제가 이렇게 프로세스에게 환상을 보여주는 이유는 무엇일까?**

프로그래머에게 쉬운 시스템을 제공하기 위해서이다. 각 프로세스에게 거대하고 연속된 주소 공간의 환상을 만들어 버리면 프로그래머는 해당 변수를 어느 위치에 저장할지에 대한 노력을 할 필요가 없다. 만약에 운영체제가 이런 환상을 프로세스에게 주지않았더라면 빽빽하고 좁은 공간에 데이터를 어느 위치에 넣을지는 개발자의 몫이 될것이다.

다른 이유로는 isolation과 protection이다. A 프로그램이 B 프로그램의 메모리를 읽고 잘못된 데이터를 덮어쓰거나 수정하는거를 막기위한 이유이기도 하다.

주소 공간(Address Space)

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%201.png)

옛날 컴퓨터들의 물리 메모리 그림을 보면 하나의 프로그램(프로세스)가 있고 나머지 메모리를 사용한다. 가상화도 없고 별로 특별한게 없던 시절이라 개발자는 꿀을 빨수 있었다.

모든 고난의 길은 사용자 편의성과 고성능, 안정성을 사용자들이 원하기 시작한 후다.  컴퓨터는 비싼 장비였기에 효율적으로 컴퓨터를 공유하기 위해 멀티프로그래밍이 등장한다. 

여러 프로세스를 올려놓고 운영체제는 빠르게 프로세스들을 전환해가며 CPU의 효율을 높였다. 더 많은 사람들이 컴퓨터 사용을 원하자 Time Sharing이 등장했다. 사용자들이 동시에 사용하며 현재 작업의 응답을 바로 받을수있는 Interactivity, 마치 대화를 하는듯한 방법을 사용하였다.

이상적으로 보이는 Time sharing의 큰 결함이 존재했는데 운영체제가 프로세스에게 생명을 불어넣는순간 모든 메모리 접근 권한을 가지게된다 다른 프로세스로 전환되기전에 모든 상태 정보들을 메모리에 저장하고 턴을 마치게 되는데 단순 레지스터 상태를 저장하고 다시 불러오는거는 빠르지만 메모리 전체 내용을 디스크에 저장하는게 매우 매우 느리다. 다른 프로세스 전환마다 그러면 이건 쓸 수 없는 방법이 되버린다. 

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%202.png)

프로세스 전환할때 메모리를 그대로 프로세스에 유지하기 위한 상황이 다. 512KB 메모리에 프로세스 3개가 들어있다. 프로세스 A가 실행중일때 B,C는 큐에서 대기하게된다. 

이렇게 여러 프로그램이 하나의 메모리를 공유하면서 존재하려면 proection의 문제가 부곽되게된다. 갑자기 B,C 프로세스에서 A메모리 읽고 데이터까지 수정 변경되어 저장된다면 이건 심각한 상황이다.

![Untitled](Memory%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20ec2eb4302d1a47a5824eaa183f92197d/Untitled%203.png)

## 메모리 가상화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c08dde42-4375-423c-80c7-980620022683/Untitled.png)

개노답 프로세스 삼형제들에게 이런 상황을 보지않기위해 운영체제는 프로세스에게 환상을 심어준다, 메모리 가상화이다. 마치 개노답 삼형제들은 본인이 특정한 위치에 엄청난 크기의 전용 메모리를 가지게된다고 생각하지만 실제로는 하드웨어의 도움을 받아 가상주소를 물리주소로 변환시키며 가상화 데이터를 끄집어 내게된다. 

메모리를 가상화 하기위한 조건이 몇가지 존재한다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/57c2fd2d-77ca-4fcd-b5a9-ce2c21b2a448/Untitled.png)

### Isolation

바로 Isolation 이다. 튼튼한 시스템을 만드는데 가장 중요한 핵심이다. 프로세스가 운영체제에게 기어오르는걸 막아야한다. 한 프로세스가 다른 프로세스에게 피해를 줘소도 안되고 운영체제 동작에 문제를 일으켜서도 안된다. 

### transparency

프로세스의 눈을 속여라 본인들이 찐 물리주소를 가지고있다고 착각해야 더 많은 내용을 공유할수있다. 

### efficiency

그렇다고 가상화를 위해 너무 많은 메모리를 사용하면 느려진다. 하드웨어의 도움도 필요하니 적절하게 섞어 효율적이게 가상화시켜야한다.

### protection

운영체제는 프로세스가 다른 프로세스 영향주는것도 막아야하고 본인도 프로세스가 깝치는걸 막아야한다.

우리가 코드로 주소를 출력하면 0x108529afe20같은 주소가 나오게되는데 우리가 볼수있는 주소는 모두 가상주소다. 찐 물리 메모리 주소는 운영체제와 하드웨어만이 알수있다.

### 어떻게 효율이면서 유연하게 메모리 가상화를 시킬까?

이전에 CPU 가상화 설명하면서 나온 limited 실행을 떠올려보면 거기의 연장선으로써 하드웨어를 사용하여 가상 주소를 실제 물리 주소로 변환하는 **주소 변환** 방법이 있다. 

하드웨어가 알아서 뚝 딱 주소 변환시켜주는게 아니라 운영체제가 중간에 나서서 메모리의 사용 공간이 비었는지 아닌지 제어하고 난 후 하드웨어를 사용한다.

첫번째 시도는 민망할정도로 간단하게 시작한다. 여기서 가정을 한번 해보자. 주소 공간이 물리 메모리에 연속되게 저장되어야된다 치자. 당연히 주소 공간 크기가 작다고 가정해야되고 물리 메모리의 주소 공간또한 동일하다는 비현실적인 가정을 지은채로 현실적으로 바꾸면서 풀어보자.

time sharing에서는 base and bound라는 방법이 선택되었다 동적 배치라고도 말하는데 CPU는 2개의 하드웨어 레지스트리를 요구한다 그게 BASE랑 BOUND다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/688c0d98-3737-4966-a1cf-a37239bd5b0c/Untitled.png)

Base와 Bound는 프로세스가 자기 주소에만 접근할수있게 도와준다. 프로그램이 시작하면 운영체제는 물리 메모리 주소를 결정해주고 베이스 레지스터를 결정한 주소값으로 세팅한다.

프로세스에서 생성되는 모든 주소는 다음과 같이 변환될거다. 

가상주소에서 base를 더한 값이 찐 물리주소다.

```java
physical address = virtual address + base
```

동적 재배치라고 불리는 이유도 프로그램 시작할때부터 계속 주소 공간을 이동시킬수있는데 이전 운영체제를 보면 정적 재배치라고 하드웨어 도움없이 소프트웨어로 메모리 주소 할당해주다가 피를 보았기 때문이다. 

다른 프로세스나 운영체제 메모리 마음만 먹으면 넘나들수도있고 한번 배치후에 재배치가 까다로워서 현대 OS는 동적 재배치를 사용한다. 그런데 base bound라면서 bound는 어디있는가?

bound는 레지스터를 보호하는 기능을 가지고있다. 16KB로 설정된 바운드의 크기는 프로세스가 바운드보다 크거나 음수인 주소에 접근시도할때 CPU는 예외를 터트리고 종료된다. 

이러한 하드웨어의 도움을 통해 잘못된 접근을 막고 모든 메모리 접근 권한을 제어하는 운영체제는 올바른 값으로의 주소 접근을 허용시킨다. 하지만 이런 동적 재배치는 큰 물리 메모리공간에 박혀있는 프로세스 스택과 힙이 작기때문에 빈 공간의 차이가 크게 생긴다. 이런걸 **메*모리 내부 단편화***라고 한다.

메모리에 프로세스를 더 넣을수있는데도 고정된 크기로 넣어야해서 메모리 단편화를 겪게된다. base&bound의 효율성을 가지며 이걸 해결하기위해 **세그멘테이션**이 등장한다.
