CPU 스케줄링
설명에서 사용될 가정들은 매우 이상적이며 현실에서 일어날수없다. 내용이 심화됨에 따라 가정을 현실적으로 바꿔가며 마지막에는 올바른 스케줄링을 느끼게될거다.
다음과 같은 비현실적인 가정을 해보자.
모든 작업은 동시에 도착하며 같은 시간 동안 실행된다. 
각 작업은 끝날때까지 실행하며 입출력을 배제한 CPU만 사용한다.
First In First Out, FIFO

A,B,C 동시 도착에 A,B,C 순서대로 도착했고 10초동안 실행되었다. 평균 반환값은 A+B+C/3 인 = 20이다. 계산은 쉽다. 현실적인 가정으로 돌아가보자. 작업 실행 시간이 똑같지않다라고 하면 FIFO의 미래는? 

보다싶이 A가 100초나 먹고 B, C 까지 다시 계산하면 평균 반환시간은 110초다. 이런 문제점을 Convoy effect라고 한다. 5인큐를 돌렸는데 1명이 로딩이 너무 느려서 1%남기고 99%까지 채운 나머지 4명이 고통을 받는다. 작업 실행 시간이 다르다는 현실적인 가정이면 무슨 알고리즘이 베스트인가?
Shortest Job First, SJF

젤 작업시간 많이 차지하는놈을 마지막에 처리하고 짧게 끝나는 작업들을 먼저 처리하는거다. 10+20+120/3만 해도 50초다. 110초에 비하면 2배 넘게 빨라졌다. 그럼 다시 모든 작업이 동시에 도착하지 않는다는 현실적인 가정으로 업그레이드 한다면? 
A가 t=0에 제일 빠르게 도착하고 100초동안 돌아가고 B와 C는 t=10에 도착하고 10초동안 돌아간다고 생각하면 B와 C가 A 바로 뒤에 도착해도. 일단 제일 먼저 도착한 A가 또 다시 100초동안 convoy effect를 일으킨다.
 
쉬어가자. 옛날 시절에는 작업이 종료될 때까지 계속 실행하는 non-preemptive 비선점형 스케줄러를 사용했는데 **현대 시대에는 대부분 선점 스케줄러를 사용**한다.  어떻게? 현재 프로세스 중단하고 Context Switch를 통해 다른 프로세스 실행시키면서. 

## Shortest Time-to-Completion First, STCF

SJF는 비선점 스케줄러라 끝날때까지 아무것도 못하지만 우리가 Context Switch나 타이머 인터럽트를 생각해본다면 다시 현실적인 가정을 해보자. A를 중단 시키고 B나 C를 실행할수도 있다. 

B와 C도착할때까지만 A일을 하다가 바로 뺏들어어서 B, C 10초씩 일 끝내고 다시 A돌리면 되지않는가? 그렇기에 최적의 스케줄링이라 한다. 하지만 초기 컴퓨팅에서만 인정받고 Time Sharing이 등장하며 뒤바뀌게 되었다.

앞으로는 평균 반환값으로 평가되는게 아니라 응답 시간으로 평가된다. A,B,C 가 동시에 도착하는 경우 C는 한 번 작업하기위해 A와 B가 끝날때까지 기다린다. 평균 반환 시간은 좋지만 응답 시간은 좋다고 할수가 없다. 

“명령어를 입력하고 시스템으로부터 응답을 받기까지 10초 기다리는걸 상상해보자 그저 다른 작업이 내 명령어보다 먼저 스케줄링 되었다는 이유로 말이다.

## Round-Robin, RR

쎈시티브한 응답시간을 위해 라운드 로빈이라는 스케줄링 알고리즘이 등장한다.
