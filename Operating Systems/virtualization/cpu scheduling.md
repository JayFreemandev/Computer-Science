CPU 스케줄링
설명에서 사용될 가정들은 매우 이상적이며 현실에서 일어날수없다. 내용이 심화됨에 따라 가정을 현실적으로 바꿔가며 마지막에는 올바른 스케줄링을 느끼게될거다.
다음과 같은 비현실적인 가정을 해보자.
모든 작업은 동시에 도착하며 같은 시간 동안 실행된다. 
각 작업은 끝날때까지 실행하며 입출력을 배제한 CPU만 사용한다.
First In First Out, FIFO

A,B,C 동시 도착에 A,B,C 순서대로 도착했고 10초동안 실행되었다. 평균 반환값은 A+B+C/3 인 = 20이다. 계산은 쉽다. 현실적인 가정으로 돌아가보자. 작업 실행 시간이 똑같지않다라고 하면 FIFO의 미래는? 

보다싶이 A가 100초나 먹고 B, C 까지 다시 계산하면 평균 반환시간은 110초다. 이런 문제점을 Convoy effect라고 한다. 5인큐를 돌렸는데 1명이 로딩이 너무 느려서 1%남기고 99%까지 채운 나머지 4명이 고통을 받는다. 작업 실행 시간이 다르다는 현실적인 가정이면 무슨 알고리즘이 베스트인가?
Shortest Job First, SJF

젤 작업시간 많이 차지하는놈을 마지막에 처리하고 짧게 끝나는 작업들을 먼저 처리하는거다. 10+20+120/3만 해도 50초다. 110초에 비하면 2배 넘게 빨라졌다. 그럼 다시 모든 작업이 동시에 도착하지 않는다는 현실적인 가정으로 업그레이드 한다면? 
A가 t=0에 제일 빠르게 도착하고 100초동안 돌아가고 B와 C는 t=10에 도착하고 10초동안 돌아간다고 생각하면 B와 C가 A 바로 뒤에 도착해도. 일단 제일 먼저 도착한 A가 또 다시 100초동안 convoy effect를 일으킨다.
 
쉬어가자. 옛날 시절에는 작업이 종료될 때까지 계속 실행하는 non-preemptive 비선점형 스케줄러를 사용했는데 **현대 시대에는 대부분 선점 스케줄러를 사용**한다.  어떻게? 현재 프로세스 중단하고 Context Switch를 통해 다른 프로세스 실행시키면서. 

## Shortest Time-to-Completion First, STCF

SJF는 비선점 스케줄러라 끝날때까지 아무것도 못하지만 우리가 Context Switch나 타이머 인터럽트를 생각해본다면 다시 현실적인 가정을 해보자. A를 중단 시키고 B나 C를 실행할수도 있다. 

B와 C도착할때까지만 A일을 하다가 바로 뺏들어어서 B, C 10초씩 일 끝내고 다시 A돌리면 되지않는가? 그렇기에 최적의 스케줄링이라 한다. 하지만 초기 컴퓨팅에서만 인정받고 Time Sharing이 등장하며 뒤바뀌게 되었다.

앞으로는 평균 반환값으로 평가되는게 아니라 응답 시간으로 평가된다. A,B,C 가 동시에 도착하는 경우 C는 한 번 작업하기위해 A와 B가 끝날때까지 기다린다. 평균 반환 시간은 좋지만 응답 시간은 좋다고 할수가 없다. 

“명령어를 입력하고 시스템으로부터 응답을 받기까지 10초 기다리는걸 상상해보자 그저 다른 작업이 내 명령어보다 먼저 스케줄링 되었다는 이유로 말이다.

## Round-Robin, RR

쎈시티브한 응답시간을 위해 라운드 로빈이라는 스케줄링 알고리즘이 등장한다.
쎈시티브한 응답시간을 위해 라운드 로빈이라는 스케줄링 알고리즘이 등장한다. 사나이 라운드 로빈은 기다리지 않는다. 작업이 실행하는 시간을 “**타임 슬라이스**” 라고 한다. 타임 슬라이스별로 짤라버리는것이다. 일정 시간 실행 후 다음 작업으로 전환해버린다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/74c6f07b-dce2-4c39-8698-324737939199/Untitled.png)

SFJ보면 A,B,C 5초씩 1초마다 타임슬라이스 해버리는 라운드로빈은 초단위로 작업을 빠르게 왔다 갔다하기 시작한다. 라운드 로빈의 평균 응답 시간은 0+1+2 / 3 = 1이고 SJF는 0+5+10/3 = 5이다. 

타임 슬라이스가 짧아질수록 반환 성능은 좋아지지만 너무 짧게도 너무 길게도 잡아서는 안된다. Context Switch는 저장한 레지스터를 꺼내오는 작업말고 CPU 캐시, TLB 등 다양한 작업 정보 저장이 들어있기에 이런 작업은 적지 않은 비용이 발생할 수 밖에 없다.

## No More Oracle

평균 반환값은 빠르지만 응답 시간은 느린 SJF, STCF. 응답 시간은 빠르지만 반환 시간은 느린 RR.  서론에 말한 이상적인 가정들을 조금씩 풀어보자. 입출력없는 프로그램은 의미가없으며 모든 시간들을 미리 내려다보고 결과를 알고 실행하는 스케줄러는 존재하지않는다. 

입출력이 더해지는 순간 프로세스는 가장 짧은 작업을 선택하며 왔다 갔다 오갈것이다. 이렇듯 서로 역설적인 상황이며 미래를 내다볼수없는 운영체제의 문제는 해결할수없었다. 

하지만

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2cadf582-51f9-4941-9049-525b634f465f/Untitled.png)

가까운 과거를 통해 미래를 예측한다. “**멀티 레벨 피드백 큐**” 등장.
## Multi-level Feedback Queue, MLFQ

짧은 작업 먼저끝내고 반환시간 줄인다. (SJF, STCF) 

스크린을 쳐다보며 기다리는 사용자를 위해 응답 시간을 최적화한다.

MLFQ는 큐로 이루어지며 우선순위(priority level)을 따른다. 여러 단계의 큐를 피드백으로 우선순위를 정하게된다. 과거의 결과가 우선순위를 결정하게된다.

긴 작업과 짧은 작업을 잘 처리하고 입출력이 섞인 대화형 작업에서도 좋은 응답 시간을 보여주기에 완벽하게 보이지만 문제점이 없는것은 아니다. 

기아(starvation)을 일으킨다. 왜냐 시스템에 대화형 작업이 많아지면 그 작업들이 CPU다 잡아먹고 나머지 작업들은 할당받지못해 기아상태로 굶어 죽는다. 

공격에 취약하다. 이게 무슨소리냐? 어차피 타임 슬라이스로 여러 작업들을 오가며 수행하게된다. 만약에 타임슬라이스 끝나기전에 악의적인 의도로 입출력 요청을 보내면? 나는 스케줄러를 속여서 시간을 더 할당 받게된다. 99%의 타임 슬라이스를 실행후 CPU를 받게되면 “**독점**” 할수있다

문제를 해결하기 위한 방법으로는 다음과 같다. 기아상태를 해결하기 위해 모든 작업을 최상위큐로 보낸다 S시간 이후에  최상위 큐로 보내는 의미는 높은 우선순위 작업들을 CPU와 공유하게되서 프로세스가 굶지 않는다. 

### 흑마술

그 특정 S시간을 결정하는게 중요한데 얼마로 해야할까? 덕망있는 연구원 John Ousterhout는 S값을 “voodoo constants”라고 언급했다. 정확한 S값을 뽑아 내기위해 흑마술이 필요하다. 너무 길면 기아상태가 발생하고 너무 짧으면 대화형 작업에서 CPU할당이 부족하다.

MLFQ은 우선순위를 비교했을때 높은 작업만 실행하고 같으면 라운드로빈으로 타임슬라이스 방식으로 작업을 처리하게된다. 기아 상태를 해결하기위해 작업을 최상위 큐에 배치하며 처리하는 알고리즘이고 대부분의 현대 운영체제인 window에서도 기본 스케줄러로 사용중이다.

MLFQ는 정리하면서 딥하게 적지않았다. CPU의 스케줄링 알고리즘으로는 이런게 있다라는것만 짚고 넘어가고 싶기때문이다.
