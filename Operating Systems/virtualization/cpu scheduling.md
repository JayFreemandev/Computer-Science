CPU 스케줄링
설명에서 사용될 가정들은 매우 이상적이며 현실에서 일어날수없다. 내용이 심화됨에 따라 가정을 현실적으로 바꿔가며 마지막에는 올바른 스케줄링을 느끼게될거다.
다음과 같은 비현실적인 가정을 해보자.
모든 작업은 동시에 도착하며 같은 시간 동안 실행된다. 
각 작업은 끝날때까지 실행하며 입출력을 배제한 CPU만 사용한다.
First In First Out, FIFO

A,B,C 동시 도착에 A,B,C 순서대로 도착했고 10초동안 실행되었다. 평균 반환값은 A+B+C/3 인 = 20이다. 계산은 쉽다. 현실적인 가정으로 돌아가보자. 작업 실행 시간이 똑같지않다라고 하면 FIFO의 미래는? 

보다싶이 A가 100초나 먹고 B, C 까지 다시 계산하면 평균 반환시간은 110초다. 이런 문제점을 Convoy effect라고 한다. 5인큐를 돌렸는데 1명이 로딩이 너무 느려서 1%남기고 99%까지 채운 나머지 4명이 고통을 받는다. 작업 실행 시간이 다르다는 현실적인 가정이면 무슨 알고리즘이 베스트인가?
Shortest Job First, SJF

젤 작업시간 많이 차지하는놈을 마지막에 처리하고 짧게 끝나는 작업들을 먼저 처리하는거다. 10+20+120/3만 해도 50초다. 110초에 비하면 2배 넘게 빨라졌다. 그럼 다시 모든 작업이 동시에 도착하지 않는다는 현실적인 가정으로 업그레이드 한다면? 
A가 t=0에 제일 빠르게 도착하고 100초동안 돌아가고 B와 C는 t=10에 도착하고 10초동안 돌아간다고 생각하면 B와 C가 A 바로 뒤에 도착해도. 일단 제일 먼저 도착한 A가 또 다시 100초동안 convoy effect를 일으킨다.
 
