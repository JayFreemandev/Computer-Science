스케줄링
작업의 처리 순서를 결정하는것

스케줄링 목표
일괄처리 운영체제
- 처리량 극대화(주어진 시간안에 얼마나 많은 프로세스를 처리하느냐)  
- 반환시간의 최소화  
- CPU 활용의 극대화  

시분할 운영체제  
- 빠른 응답시간
- 과다한 대기시간 방지

실시간 운영체제
- 처리기간 맞춤 

**preemptive 선점 스케쥴**
실행 중인 프로세스 인터럽트 걸고 뺏어서 다른 CPU에 할당시킨다.  
높은 우선 순위의 프로세스를 우선처리해야되는 경우 사용된다.  
하지만 운영체제 입장에서는 컨텍스트 스위칭을 시켜줘야되서 오버헤드 비용이 발생한다.  

context switching
CPU가 현재 실행하고 있는 프로세스의 컨텍스트를 PCB에 저장하고  
다른 프로세스의 PCB로부터 컨텍스트를 복원하는 작업을 의미한다.  

비선점 스케줄링  
실행 중인 프로세스를 바로 준비상태로 전이시킬 수 없는 방식  
cpu를 할당 받아 실행이 시작된 상태는 대기나 종료되기전까지 계속 실행된다.  
강제적인 컨텍스트 스위칭이 발생하지 않아 오버헤드 비용이 없지만 긴 프로세스가 작업중이면  
짧은 프로세스가 오래 기다리게 된다.

FCFS(first come first served)
- 비선점
- 준비큐에 도착한 순서대로 디스패치
-> 비선점이라 긴 프로세스 기다려야되서 시분할이나 실시간 운영체제에는 부적합하다

SJF -> short job first  
FCFS의 반대로 짧은것부터 처리하는 방식 하지만 이미 긴 프로세스가 진행중이면 기다려야함  
-> 위와 마찬가지로 비선점이라 시분할, 실시간은 부적합  

SRT
SJF를 선점으로 바꾼 알고리즘 방식이다. 작업하다 더 짧은 작업이 들어오면 CPU 뺏어서 할당시킨다.  
SJF보다는 평균대기시간이나 평균반환시간에서 효율적인데 단점이 컨텍스트 스위칭때문에 오버헤드 비용이 발생하고  
진행중에 짧은 작업이 들어오면 그거부터 처리하기때문에 각 프로세스의 실행 시간 추적이 까다롭다.  

RR(Round Robin)  
선점 방식이고 준비 큐에 도착한 순서대로 디스패치하지만 정해진 시간 할당량에 의해서 실행 제한둔다.  
시간 할당량 안에 해결못한 프로세스는 그대로 꼬리칸에 끌려가서 준비 큐의 마지막에 배치된다.  
CPU를 독점하지 않고 공평하게 사용해서 시분할에 적합하지만 시간 할당량을 잘 잡아야한다.  
시간 할당량이 너무 짧으면 CONTEXT SWITCHING이 무분별 발생해서 오버헤드 비용이 늘고 길면 FCFS 스케줄링과 동일하다.  
