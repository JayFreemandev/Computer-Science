# 메모리

**단일 프로그래밍 환경**

초기 시스템은 오직 하나의 프로세스만 메모리를 전용으로 사용해서 나머지는 기다려야하는 연속 메모리 할당 방식을 이용했다. 아쉽게 메모리 용량을 초과하는 프로세스는 실행 불가하고 지속적으로 사용되지 않는 프로세스도 메모리에 계속 적재하고있어서 낭비가 심하다.

**다중 프로그래밍 환경**

여러 개의 프로세스가 메모리에 적재되는 것, 프로세스 1이 CPU 이용중이면 프로세스2는 준비상태로 기다린다. 결국 CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량을 증가시켰다.

**메모리 분할**

여러 프로세스를 메모리에 적재시키기 위해 하나의 분할에 하나의 프로세스를 적재하는 방법이다. 이 방법에서 고정 분할이냐 동적 분할이냐나뉜다.

**고정 분할**

메모리를 여러 개의 고정된 영역으로 분할하는 방식, 프로세스의 크기가 분할영역 크기보다 작으면 메모리가 남게 되어 낭비되는 단편화 현상이 발생한다.

해결 하려면 미리 프로세스 크기를 알고 그에 맞춰서 고정 분할을 시도해야되는데 쉽지 않은 방식이다.

**동적 분할**

메모리 분할 경계가 프로세스에 필요한 만큼 할당하는 방식이다.

필요한 시점에 딱 필요한 만큼 받아서 내부 단편화가 일어나지 않는다.

하지만 메모리의 할당과 반환이 반복되며 작은 크기의 공백 메모리가 흩어져 발생하는 외부 단편화 현상이 존재한다.

**외부 단편화를 해결하려면**

coalecing이라는 통합과 compaction이라는 집약이 있다.

**통합**

인접된 공백을 더 큰 하나의 공백으로 만들어버리기 하지만 통합하더라도 메모리 내에서 여기저기 크게 차지하는 경우가 발생한다. 하나의 프로세스가 일정 크기의 큰 메모리 영역이 필요할 때 끌어모은 공백의 합은 필요한 영역보다 크지만 제일 큰 공백 하나로는 그 프로세스를 수행할 수가 없는 상황이 생긴다. (인접한 메모리만 끌어모으기 때문)

**집약(compaction)**

통합의 문제를 해결하기 위해 집약은 메모리 내의 모든 공백을 하나로 끌어모은다. 

**메모리 보호**

여러 프로세스가 동시에 메모리 상주해야되는 상황이 있다. 연속 메모리 할당 방식에서는 프로세스가 사용할 수 있는 주소 레지스터 범위를 제한시키면서 다른 할당영역 침범을 막는다. 만약 프로세스가 제한을 넘어서 운영체제 호출하려면 시스템콜이 필요하다.

**메모리 배치기법**

동적 분할 ↔ 다중 프로그래밍에서 새로 반입된 프로그램이나 데이터를 메모리 어디에 위치할것인가

운영체제는 빈 공간 리스트를 가지고있어서 적한한 공간을 찾는 4가지 배치기법이 존재한다.

**최초 적합(first in)**

빈 공간 리스트를 메모리 주소순으로 유지하며 빠르게 가장 먼저 발견된곳을 할당

**후속 적합(next fit)**

**최적 적합(best fit)**

큰 빈공간을 최대한 많이 남겨 놓기 위한 방법이다. 필요한 공간중 가장 작은곳을 할당

**최악 적합(worst fit)**

필요한 공간중 가장 큰 곳을 할당시켜준다.

**가상 메모리**

컴퓨터 메모리보다 더 큰 기억 공간이 필요한 프로세스를 실행할 수 있게 하는 방법, v프로세스에 의해 참조되는 주소를 메모리에서 사용하는 주소와 분리시키는것이 핵심이다.

전체중 현재 필요한 일부분만 메모리에 적재시켜서 프로세스 수행이 가능하게 만든다. 이때 실행 프로세스가 참조하는 주소를 가상주소, 실제 메모리 주소를 실주소(물리적 주소)

**매핑**

프로세스는 오직 가상주소만을 참조하지만 실제로메모리에서 실행 되야해서 가상주소는 → 실주소 변환이 필요한데 이 과정을 mapping 이라고 한다.

운영체제가 알아서 사상(mapping)해주기 때문에 사용자는 가상주소를 실주소 매핑에 대해서는 몰라도 된다. 이 매핑이 빨리 되야 성능이 향상된다.

**DAT(**동적 주소 변환)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89fff5f5-3d2b-42c8-9954-02bac538bdb4/Untitled.png)

가상 주소 공간에서 연속적인 주소가 실주소에서까지 연속적일 필요 없다. 사용자는 프로그램과 데이터가 실제 메모리 어디에 위치하는지 몰라도 된다. 

이때 가상주소가 현재 메모리에 어디에 위치하는지 매핑 테이블을 유지해야되는데 주소변환시 변환에 필요한 정보가 너무 많다면 매핑 테이블의 크기가 프로세스가 요구하는 메모리보다 더 큰 상황이 발생한다.

매핑 테이블의 양을 줄이는것이 효율적인 가상메모리 구현

**블록 단위 변환**

항목별 DAT 단점 극복을 위해 메모리 어디있는지 블록만 관리하자

블록의 크기가 커질수록 매핑테이블 요구 메모리는 적어지지만 블록을 보조기억장치 → 메모리 혹은 그 반대로 이동시키는 전송시간이 늘어나고 한 블록이 차지하는 메모리 공간이 커져서 메모리를 공유할 수있는 프로세스의 수가 줄어든다.

블록의 크기가 작아지면 전송시간이 줄고 프로세스 공유수가 늘어나는 대신 매핑 테이블의 요구 메모리가 커지게 된다. 적절한 블록 크기 선택이 필요함 

블록의 크기가 동일한 경우를 페에지라고 부르고 이런 가상 메모리 구성을 페이징 기법이라고한다. 세그먼트는 크기가 서로 다른 블록으로 이런 가상 메모리 구조를 세그먼테이션 기법이라고부른다.

이 두 기법을 결합하여 고정된크기의 페이지로 이루어진 다양한크기의 세그먼트를 구현하는 시스템도 존재

**페이징**

가상 메모리를 고정된 크기의 블록인 page 단위로 나눠 관리하자

메모리 보호도 페이지 단위로 동일 크기로 쪼개기때문에 외부 단편화는 발생하지않는다 

대신 페이지 내에서 내부 단편화는 발생한다.

**세그멘테이션**

다양한 크기의 블록으로(세그먼트) 단위로 가상 메모리를 나누어 관리하자

**페이지 교체 알고리즘**

페이징 기법에서 모든 페이지 프레임을 사용하고있다.

메모리에 새로적재되어야 할 페이지가 들어오면 교체 대상 페이지 프레임을 고르고

그 내용을 보조기억장치 보관후 새로운 페이지를 적재하는 과정을 거친다.

최적의 성과를 위해서 페이지 프레임중 가장 오래동안 사용되지 않을 페이지를 골라야된다.

이를 최적화 원칙이라고 하는데 이론상 완벽하지만 미래를 예측할 수는 없어서 실제 구현은

불가능하다.

**FIFO 교체**

메모리 내에 가장 오래 있었던 페이지를 교체 대상으로 지정하는데 실제로 메모리에서 오래

있었던 페이지는 앞으로도 사용할 수 있는 페이지라 이걸 교체할  가능성이 높다

또 다른 단점은 Belady의 이상현상이다.

프로세스에 더 많은 페이지 할당 → 더 많은 부재 발생

**LRU 교체**

가장 오래동안 사용되지 않은 페이지를 교체한다. 

Belady의 이상현상이 발생하지않는다 하지만 예외 케이스는 존재한다.

예를 들어 하나의 프로세스가 여러 페이지로 구성되는 커다란 루프를 가지고있을때 오래동안 사용되지않았던 페이지는 곧 가까운 미래에 사용될 페이지가 된다.

LRU는 막대한 오버헤드를 초래한다 매번 시간을 기록하고 가장 오래된 참조시간을 찾거나 리스트를 유지하는것은 큰 오버헤드라 LRU 기법 자체는 별로 이용되지않는다.

**LFU 교체**

LRU와 유사하다 페이지가 얼마나 사용되었는가 참조 횟수가 적은놈 교체

똑같이 참조 회수기록이라 오버헤드가 크다
