여러개의 CPU(멀티 프로세서)에서 병행 프로세스가 실행되는 경우 메모리 구조에 따라 차이가 있다.

**tight coupled**

여러 CPU가 하나의 기억장치를 공유한다, 하나의 운영체제가 모든 CPU와 하드웨어를 제어해서 master/salve 환경이나 SMP(대칭구조)가 해다왼다.

**loosely coupled**

2개 이상의 독립된 컴퓨터 시스템이 네트워크를 통해 연결된다. 각 시스템은 자신의 운영체제와 기억 장치를 가지고 있으며, 독립적으로 운영되고 필요할 때 통신한다. 서로 참조가 가능해서 부하 조절이 필요할때 도움받는다. 

RPC 호출 방식을 이용하며 클러스터 구조가 위 환경에 해당한다.

병행 프로세스는 프로세스 간의 관계에 따라 독립이냐 협력이냐 나뉜다.

**독립 프로세스**

다른 프로세스에 영향을 주지도 받지도않는다. 공유도 안하고 다른 프로세스 상관없이 중지되거나 재시작이 가능한 프로세스다.

**협력 프로세스**

수행 중인 다른 프로세스와 영향을 주고받는 프로세스이다 데이터 공유하고 독립 프로세스와 다르게 비결정적이며 재생이 불가능하다. 데이터가 동일 하더라도 결과가 달라질 수 있다. 두 사람이 한 계좌에 돈을 입금하거나 출금하는 예시가 그 예다.

병행성과 관련된 문제가 발생할 수 있다.
상호배제(mutual exclusion)은 2개 이상의 프로세스가 동시에 임계영역을 접근 금지
동기화는 2개 이상의 프로세스에 대한 처리 순서를 결정, 상호배제도 동기화 문제

통신

프로세스간 통신은 공유 메모리 or 메시지 두가지 방법이다. 이 두가지 방법은 하나의 운영체제에서 함께 사용될 수 있다.

공유 메모리

협력 프로세스가 동일한 변수를 사용함으로써 데이터 공유한다. 각 메모리에 직접 접근하여 대량의 데이터를 읽을 수 있어서 속도가 좋다. 대신 생산자-소비자, 판독기-기록기 문제처럼 상호배제나 동기화같은 통신중 발생 문제를 해결해야한다.

메세지

커널이 제공하는 연산 send와 연산 receive를 사용하여 데이터를 공유, 매번 시스템 호출이기 때문에 소량의 데이터가 적절하고 대신 통신상 발생 문제는 운영체제가 책임진다.

운영체제는 다음과 같은 메세지 전달방법과 논리적인 과정이 존재한다.

통신 링크

두 프로세스가 메세지 주고 받을때 그 사이 통신 링크가 존재한다. 형태 변환에 자유롭다

- 하나의 링크에 n개의 프로세스
- 하나의 프로세스 n개의 링크
- 링크의 방향성을 단방향 or 양방향?
- 링크의 용량은 뭘로?

직접 통신

두 프로세스가 서로를 지정해서 주고 받는다. 하나의 통신 링크가 자동으로 설정되고 양방향으로 제공한다. 이때를  대칭형 주소 지정이라고하고 수신자가 송신자를 미리 정하지않고 메세지 받을 때 송신자 이름 받으면 비대칭 주소라한다.

비대칭형은 receive처럼 메세지를 m에 받으며 이름을 id에받는 형태로 수신자가 여러 송신자와 통신 링크를 가지는 경우 사용된다.

간접 통신

두 프로세스 사이 우체통놔두고 알아서 메세지 주고 받는다. 이때 통신 링크는 두프로세스가 같은 우편함 사용할때, 하나가 송신자면 다른 하나는 수신자여야된다. 

수신자가 여러개일수도 있어서 누가 메세지 받을것인지 한순간에 하나의 수신자만 접근하도록 관리한다. 이 경우 수신자 송신자 역할이 바뀔수도 있어서 통신 링크는 양방향으로볼 수 있다.

**교착상태**

여러 개의 프로세스가 서로 상대방의 작업만 끝나기를 기다리고있어서 어느 쪽도 영원히 진행하지 못하는 상태를 의미한다.

**기아상태**

위 교착 상태(데드락)은 프로세스가 자원 희득 가능성없이 무한히 기다리는거고 기아상태는 자원희득의 가능성은 있으나 대기상태인 것을 의미한다.

**교착상태의 조건**

4가지 조건이 동시에 만족할때 발생한다.

상호배제(mutual exclusion) 

점유대기(hold and wait) 

비선점(no preemption) 타의에 의해 해제안됨

환형대기(circular wait) 원을 이루며 자원의 요구 관계가 진행중

**교착상태 처리기법**

1. 예방

4가지 동시 만족을 피하자

1. 회피

프로세스에 필요한 자원의 최대량의 정보를 이용하여 회피하자

1. 탐지 및 복구

발생되면 정상상태로 복구하자

### 예방

**점유대기 조건 제거**

자원을 점유했을때 대기하지 않도록 하거나 대기할 때 자원을 점유하지 않도록 하면된다.

1. 한번에 다 줘 

처음에 한꺼번에 요구하여 자원을 할당받으면 그 이상 요청이 없어 제거된다.

이 방법의 단점은 미리 점유하면 실제 시점까지 자원을 활용하지못해 이용률이 떨어진다

또한 한꺼번에 요청하더라도 하나라도 바로 할당안되면 대기 → 기아상태로 빠진다.

1. 받기전 탕진

두번째 시나리오는 새로운 자원을 요구하기전 할당 받았던 자원을 탕진한다. 그러면 점유한 자원이 없어서 대기가 발생하더라도 점유대기 조건이제거된다. 이 방법의 단점은 프린터처럼 점유 도중 해제가 안되는 자원에는 적용이 불가능하다. 이런 자원을 점유하는 중에는 추가적인 요구가 발생하지않도록 한번에 다 줘를 시전하게되면 똑같이 낮은 자원이용률과 기아상태가 존재한다.

**비선점 조건 제거**

선점이 가능하게 해야되는데 자원특성에따라 불가능한 경우도 있어서 완벽하게 못한다.

프린터→ 누가 선점해서 프로세스 뺏어가면 문제 발생 차선책으로 자원을 점유한 프로세스가 다른 자원을 요구할 때 대기가 발생한다면 할당받았던 자원을 모두 해제시키는 방법인데 이것도 프린터같은 자원에는 적용이 불가능하다.

**환형대기 조건 제거**

모든 자원에 일련번호를 지정, 자원 요구시 오름차순으로 확인해서 할당하면 사이클 방지할수있는데 프로세스마다 자원의 요구순서가 다를 수있어서 일련번호 적절한 설정이 어렵다.

### 회피

프로세스의 자원 사용에 대한 사전 정보를 활용하여 교착상태가 발생하지 않는 상태에 머물게 하는 방법

사전 정보

- 현재 할당된 자원
- 가용상태의 자원
- 프로세스의 최대 요구량

안전 상태

교착상태를 회피하며 프로세스 요구량을 충족시키는 상태, 안전상태를 유지하기 위해서는 프로세스가 가용 상태의 자원을 요청하더라도 할당하지않고 대기상태가 될 수 있다. 이러면 회피도 자원이용률이 낮다.

**자원이 하나만 있는 상황**

**불안전상태**

안전순서열이 없는 상태를 말하고 불안전상태라고 무조건 교착 상태가 아니다 왜?

**예방**
