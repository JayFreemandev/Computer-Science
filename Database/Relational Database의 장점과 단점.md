유연한 확장성의 부족  
Order라는 테이블에 신규 기능이 들어가야한다
만약 주문이 로켓 배송이다? 
rocket_delivery_at 컬럼이 추가된다. 즉 스키마의 변형이 일어난다. 
지속해서 서비스가 커지면서 새로운 컬럼들이 늘어나게(스키마 변형)된다.
사업이 성공적으로 성장하면서 Order 테이블의 데이터 개수가 8000만이다.
여기서 계속 컬럼을 추가한다는것은 DB서버에 큰 write 부하를 주게 된다.
DB를 사용하는 애플리케이션에서도 부수적인 변형이 일어나고 운이 나쁘다면 
사용자에게도 영향을 줄 수있다.   

중복 제거를 위한 정규화  
중복된 값을 제거하기위해 여러 테이블로 쪼개는 정규화 과정이 필요하다. 
전체 데이터가 필요하게 될 경우 다중 JOIN이 필요하게 되는데 복잡한 JOIN
일수록 READ 성능의 하락을 불러온다.  

Scale Out의 불편함  
RDB는 기본적으로 한 대의 컴퓨터에 저장된다. 감당할 수 없을 정도의 READ/WRITE 요청이 
들어 올 경우 CPU와 메모리 사용률이 올라가고 작업에 지장을 준다면 Scale Up을 통한 
DB 성능 향상이 진행된다.  

여기서 Scale Up은 하드웨어 사양을 높이는걸 말하는데 더 좋은 CPU와 더 좋은 메모리로 교체
하거나 혹은 Replication을 통해 똑같은 DB를 나눠서 n개의 컴퓨터에 복사 시킨다. 복사된 컴퓨터는 
READ ONLY용으로 사용 할 수 있게된다.  

만약 WRITE 요청이 더 많다면? 다시 RDB 컴퓨터에 부하가 가기 시작한다. 그렇다면 MULTI 
MASTER(여러명의 MASTER 들이 WRITE를 받도록)나 SHARDING을 통해 문제를 해결할수있지만 
RDB가 SCALE OUT에 유연한 DB는 아니다.  

SECONDARY SERVER가 추가된다면 앞선 REPLICATION과 같은 SCALE OUT시 했던 복사 과정을 
다시 진행해줘야한다. SHARDING 하는 경우는 데이터를 다 옮겨야하고 서비스가 운영중인데 
데이터를 마이그레이션 한다는건 쉬운 작업이 아니다.  

TRANSACTION ACID의 TRADE OFF  
ACID자체가 좋은 장점이지만 동시에 ACID를 지키기 위해 성능에 좋은 영향을 주지는 않는다.
